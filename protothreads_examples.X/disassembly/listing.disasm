Disassembly Listing for protothreads_examples
Generated From:
C:/Users/links/MPLABXProjects/protothreads_examples.X/dist/default/debug/protothreads_examples.X.debug.elf
25/08/2016 9:20:49 PM

---  c:/users/links/mplabxprojects/protothreads_examples.x/pt_cornell_eg1.c  ----------------------------
1:                   /*
2:                    Bruce Land PT eg1
3:                    */
4:                   #define _SUPPRESS_PLIB_WARNING 1
5:                   #include <xc.h>                         // Include device specific features
6:                   #include <plib.h>                       // Peripheral Library
7:                   #include "pt.h"
8:                   #include <stdio.h>                      // for printf
9:                   
10:                  // PIC32MX250F128B - Microstick ii
11:                  //=============================================================
12:                  // 40 MHz
13:                  // FRC -8MHz-> FPLLIDIV (2) -4MHz-> FPLLMUL (20) -80MHz-> FPLLODIV (2) --40MHz
14:                  // --> SYSCLK -> FPBDIV (1) -40MHz-> PBCLK
15:                  
16:                  // DEVCFG2
17:                  // Phase Loop Lock Setup
18:                  #pragma config FPLLIDIV = DIV_2         // FRC -8MHz-> FPLLIDIV (2) -4MHz->. Must by 4-5MHz
19:                  #pragma config FPLLMUL = MUL_20         // -4MHz-> FPLLMUL (20) -80MHz->
20:                  #pragma config FPLLODIV = DIV_2         // -80MHz-> FPLLODIV (2) -40MHz->
21:                  
22:                  // DEVCFG1
23:                  // Clock
24:                  #pragma config FNOSC = FRCPLL           // Clock Source = Internal Fast RC oscillator with PLL
25:                  #pragma config POSCMOD = OFF            // Primary oscillator mode = OFF (Not used/connected)
26:                  #pragma config FSOSCEN = OFF            // Secondary oscillator disabled
27:                  #pragma config FPBDIV = DIV_1           // SYSCLK -40MHz-> FPBDIV (1) -40MHz-> SBCLK
28:                  #pragma config FWDTEN = OFF             // Watchdog timer disabled
29:                  
30:                  // DEVCFG0
31:                  #pragma config JTAGEN = OFF             // Joint Test Action Group. JTAG Port disabled
32:                  #pragma config PWP = OFF                // Program Flash Write Protect Disabled
33:                  #pragma config BWP = OFF                // Boot Flash Write Protect Disabled
34:                  #pragma config CP = OFF                 // Code Protection Disabled
35:                  
36:                  #define SYS_FREQ 40000000
37:                  #define PB_DIVISOR (1 << OSCCONbits.PBDIV)
38:                  #define PB_FREQ SYS_FREQ/PB_DIVISOR     // PBCLK. Also 40MHz
39:                  
40:                  #define BAUDRATE 9600
41:                  
42:                  // Timer2 ms timer
43:                  volatile int milliSec = 0;              // Volatile because updated in Timer2 ISR
44:                  void __ISR(_TIMER_2_VECTOR, IPL2SOFT) Timer2Handler(void)
45:                  {
9D000A8C  415DE800   RDPGPR SP, SP
9D000A90  401A7000   MFC0 K0, EPC
9D000A94  401B6000   MFC0 K1, Status
9D000A98  27BDFFE0   ADDIU SP, SP, -32
9D000A9C  AFBA001C   SW K0, 28(SP)
9D000AA0  401A6002   MFC0 K0, SRSCtl
9D000AA4  AFBB0018   SW K1, 24(SP)
9D000AA8  AFBA0014   SW K0, 20(SP)
9D000AAC  7C1B7844   INS K1, ZERO, 1, 15
9D000AB0  377B0800   ORI K1, K1, 2048
9D000AB4  409B6000   MTC0 K1, Status
9D000AB8  AFBE000C   SW S8, 12(SP)
9D000ABC  AFA30008   SW V1, 8(SP)
9D000AC0  AFA20004   SW V0, 4(SP)
9D000AC4  03A0F021   ADDU S8, SP, ZERO
46:                      mT2ClearIntFlag();
9D000AC8  3C02BF88   LUI V0, -16504
9D000ACC  24030200   ADDIU V1, ZERO, 512
9D000AD0  AC431034   SW V1, 4148(V0)
47:                      milliSec++;
9D000AD4  8F828018   LW V0, -32744(GP)
9D000AD8  24420001   ADDIU V0, V0, 1
9D000ADC  AF828018   SW V0, -32744(GP)
48:                  }
9D000AE0  03C0E821   ADDU SP, S8, ZERO
9D000AE4  8FBE000C   LW S8, 12(SP)
9D000AE8  8FA30008   LW V1, 8(SP)
9D000AEC  8FA20004   LW V0, 4(SP)
9D000AF0  41606000   DI ZERO
9D000AF4  000000C0   EHB
9D000AF8  8FBA001C   LW K0, 28(SP)
9D000AFC  8FBB0018   LW K1, 24(SP)
9D000B00  409A7000   MTC0 K0, EPC
9D000B04  8FBA0014   LW K0, 20(SP)
9D000B08  27BD0020   ADDIU SP, SP, 32
9D000B0C  409A6002   MTC0 K0, SRSCtl
9D000B10  41DDE800   WRPGPR SP, SP
9D000B14  409B6000   MTC0 K1, Status
9D000B18  42000018   ERET
49:                  
50:                  // Thread 1
51:                  // Wake up every 1s and turn LED off
52:                  static PT_THREAD(protothread1(struct pt *pt))
53:                  {
9D000B1C  27BDFFE0   ADDIU SP, SP, -32
9D000B20  AFBF001C   SW RA, 28(SP)
9D000B24  AFBE0018   SW S8, 24(SP)
9D000B28  03A0F021   ADDU S8, SP, ZERO
9D000B2C  AFC40020   SW A0, 32(S8)
54:                      // All vars must be static in pt thread
55:                      // because they are not saved to the stack when a blocking PT call is made
56:                      #define wait_t1 1000                // ms
57:                      static int time_thread_1;
58:                      PT_BEGIN(pt);                       // Start of thread.
9D000B30  24020001   ADDIU V0, ZERO, 1
9D000B34  A3C20010   SB V0, 16(S8)
9D000B38  8FC20020   LW V0, 32(S8)
9D000B3C  94420000   LHU V0, 0(V0)
9D000B40  10400006   BEQ V0, ZERO, 0x9D000B5C
9D000B44  00000000   NOP
9D000B48  2403003F   ADDIU V1, ZERO, 63
9D000B4C  10430011   BEQ V0, V1, 0x9D000B94
9D000B50  00000000   NOP
9D000B54  0B4002F2   J 0x9D000BC8
9D000B58  00000000   NOP
59:                      while (1) {
60:                          PORTACLR = _PORTA_RA0_MASK;          // LED Off
9D000B5C  3C02BF88   LUI V0, -16504
9D000B60  24030001   ADDIU V1, ZERO, 1
9D000B64  AC436024   SW V1, 24612(V0)
61:                          printf("Protothread 1 running\n");
9D000B68  3C029D00   LUI V0, -25344
9D000B6C  2444246C   ADDIU A0, V0, 9324
9D000B70  0F4008F5   JAL 0x9D0023D4
9D000B74  00000000   NOP
62:                          time_thread_1 = milliSec + wait_t1;
9D000B78  8F828018   LW V0, -32744(GP)
9D000B7C  244203E8   ADDIU V0, V0, 1000
9D000B80  AF828024   SW V0, -32732(GP)
63:                          PT_YIELD_UNTIL(pt, milliSec > time_thread_1);
9D000B84  A3C00010   SB ZERO, 16(S8)
9D000B88  8FC20020   LW V0, 32(S8)
9D000B8C  2403003F   ADDIU V1, ZERO, 63
9D000B90  A4430000   SH V1, 0(V0)
9D000B94  83C20010   LB V0, 16(S8)
9D000B98  10400006   BEQ V0, ZERO, 0x9D000BB4
9D000B9C  00000000   NOP
9D000BA0  8F838018   LW V1, -32744(GP)
9D000BA4  8F828024   LW V0, -32732(GP)
9D000BA8  0043102A   SLT V0, V0, V1
9D000BAC  14400004   BNE V0, ZERO, 0x9D000BC0
9D000BB0  00000000   NOP
9D000BB4  24020001   ADDIU V0, ZERO, 1
9D000BB8  0B4002F6   J 0x9D000BD8
9D000BBC  00000000   NOP
64:                      }
9D000BC0  0B4002D7   J 0x9D000B5C
9D000BC4  00000000   NOP
65:                      PT_END(pt);                         // Should never get here because thread is continuoues
9D000BC8  A3C00010   SB ZERO, 16(S8)
9D000BCC  8FC20020   LW V0, 32(S8)
9D000BD0  A4400000   SH ZERO, 0(V0)
9D000BD4  24020003   ADDIU V0, ZERO, 3
66:                  }
9D000BD8  03C0E821   ADDU SP, S8, ZERO
9D000BDC  8FBF001C   LW RA, 28(SP)
9D000BE0  8FBE0018   LW S8, 24(SP)
9D000BE4  27BD0020   ADDIU SP, SP, 32
9D000BE8  03E00008   JR RA
9D000BEC  00000000   NOP
67:                  
68:                  // Thread 2
69:                  // Wake up every 4s and turn LED on
70:                  static PT_THREAD(protothread2(struct pt *pt))
71:                  {
9D000BF0  27BDFFE0   ADDIU SP, SP, -32
9D000BF4  AFBF001C   SW RA, 28(SP)
9D000BF8  AFBE0018   SW S8, 24(SP)
9D000BFC  03A0F021   ADDU S8, SP, ZERO
9D000C00  AFC40020   SW A0, 32(S8)
72:                      #define wait_t2 4000                // ms
73:                      static int time_thread_2;
74:                      PT_BEGIN(pt);
9D000C04  24020001   ADDIU V0, ZERO, 1
9D000C08  A3C20010   SB V0, 16(S8)
9D000C0C  8FC20020   LW V0, 32(S8)
9D000C10  94420000   LHU V0, 0(V0)
9D000C14  10400006   BEQ V0, ZERO, 0x9D000C30
9D000C18  00000000   NOP
9D000C1C  2403004F   ADDIU V1, ZERO, 79
9D000C20  10430011   BEQ V0, V1, 0x9D000C68
9D000C24  00000000   NOP
9D000C28  0B400327   J 0x9D000C9C
9D000C2C  00000000   NOP
75:                      while (1) {
76:                          PORTASET = _PORTA_RA0_MASK;          // LED On
9D000C30  3C02BF88   LUI V0, -16504
9D000C34  24030001   ADDIU V1, ZERO, 1
9D000C38  AC436028   SW V1, 24616(V0)
77:                          printf("Protothread 2 running\n");
9D000C3C  3C029D00   LUI V0, -25344
9D000C40  24442484   ADDIU A0, V0, 9348
9D000C44  0F4008F5   JAL 0x9D0023D4
9D000C48  00000000   NOP
78:                          time_thread_2 = milliSec + wait_t2;
9D000C4C  8F828018   LW V0, -32744(GP)
9D000C50  24420FA0   ADDIU V0, V0, 4000
9D000C54  AF828028   SW V0, -32728(GP)
79:                          PT_YIELD_UNTIL(pt, milliSec > time_thread_2);
9D000C58  A3C00010   SB ZERO, 16(S8)
9D000C5C  8FC20020   LW V0, 32(S8)
9D000C60  2403004F   ADDIU V1, ZERO, 79
9D000C64  A4430000   SH V1, 0(V0)
9D000C68  83C20010   LB V0, 16(S8)
9D000C6C  10400006   BEQ V0, ZERO, 0x9D000C88
9D000C70  00000000   NOP
9D000C74  8F838018   LW V1, -32744(GP)
9D000C78  8F828028   LW V0, -32728(GP)
9D000C7C  0043102A   SLT V0, V0, V1
9D000C80  14400004   BNE V0, ZERO, 0x9D000C94
9D000C84  00000000   NOP
9D000C88  24020001   ADDIU V0, ZERO, 1
9D000C8C  0B40032B   J 0x9D000CAC
9D000C90  00000000   NOP
80:                      }
9D000C94  0B40030C   J 0x9D000C30
9D000C98  00000000   NOP
81:                      PT_END(pt);
9D000C9C  A3C00010   SB ZERO, 16(S8)
9D000CA0  8FC20020   LW V0, 32(S8)
9D000CA4  A4400000   SH ZERO, 0(V0)
9D000CA8  24020003   ADDIU V0, ZERO, 3
82:                  }
9D000CAC  03C0E821   ADDU SP, S8, ZERO
9D000CB0  8FBF001C   LW RA, 28(SP)
9D000CB4  8FBE0018   LW S8, 24(SP)
9D000CB8  27BD0020   ADDIU SP, SP, 32
9D000CBC  03E00008   JR RA
9D000CC0  00000000   NOP
83:                  
84:                  static struct pt pt1, pt2;
85:                  
86:                  int main(void)
87:                  {
9D000CC4  27BDFFA8   ADDIU SP, SP, -88
9D000CC8  AFBF0054   SW RA, 84(SP)
9D000CCC  AFBE0050   SW S8, 80(SP)
9D000CD0  03A0F021   ADDU S8, SP, ZERO
9D000CD4  3C020262   LUI V0, 610
9D000CD8  34425A00   ORI V0, V0, 23040
9D000CDC  AFC20014   SW V0, 20(S8)
9D000CE0  24020005   ADDIU V0, ZERO, 5
9D000CE4  AFC20018   SW V0, 24(S8)
88:                      int bit_rate;
89:                      
90:                      //Configure Flash wait states and prefetch cache for max performance based on SYSCLK
91:                      SYSTEMConfig(SYS_FREQ, SYS_CFG_WAIT_STATES | SYS_CFG_PCACHE);
92:                      
93:                      ANSELA = 0;                         // Allow Pins Digital
9D000EE8  3C02BF88   LUI V0, -16504
9D000EEC  AC406000   SW ZERO, 24576(V0)
94:                      ANSELB = 0;
9D000EF0  3C02BF88   LUI V0, -16504
9D000EF4  AC406100   SW ZERO, 24832(V0)
95:                      
96:                      // Setup USART IO pins
97:                      PPSInput(2, U2RX, RPB11);           // Pin 22
9D000EF8  3C03BF81   LUI V1, -16511
9D000EFC  9062FA58   LBU V0, -1448(V1)
9D000F00  24040003   ADDIU A0, ZERO, 3
9D000F04  7C821804   INS V0, A0, 0, 4
9D000F08  A062FA58   SB V0, -1448(V1)
98:                      PPSOutput(4, RPB10, U2TX);          // Pin 21
9D000F0C  3C03BF81   LUI V1, -16511
9D000F10  9062FB54   LBU V0, -1196(V1)
9D000F14  24040002   ADDIU A0, ZERO, 2
9D000F18  7C821804   INS V0, A0, 0, 4
9D000F1C  A062FB54   SB V0, -1196(V1)
99:                      
100:                     UARTConfigure(UART2, UART_ENABLE_PINS_TX_RX_ONLY);
9D000F20  24040001   ADDIU A0, ZERO, 1
9D000F24  00002821   ADDU A1, ZERO, ZERO
9D000F28  0F400994   JAL UARTConfigure
9D000F2C  00000000   NOP
101:                     //UARTSetFifoMode() // No Interrupts setup
102:                     UARTSetLineControl(UART2, UART_DATA_SIZE_8_BITS | UART_PARITY_NONE | UART_STOP_BITS_1);
9D000F30  24040001   ADDIU A0, ZERO, 1
9D000F34  00002821   ADDU A1, ZERO, ZERO
9D000F38  0F4009EF   JAL UARTSetLineControl
9D000F3C  00000000   NOP
103:                     bit_rate = UARTSetDataRate(UART2, PB_FREQ, BAUDRATE);
9D000F40  3C02BF81   LUI V0, -16511
9D000F44  8C42F000   LW V0, -4096(V0)
9D000F48  7C420CC0   EXT V0, V0, 19, 2
9D000F4C  304200FF   ANDI V0, V0, 255
9D000F50  3C030262   LUI V1, 610
9D000F54  34635A00   ORI V1, V1, 23040
9D000F58  00431007   SRAV V0, V1, V0
9D000F5C  24040001   ADDIU A0, ZERO, 1
9D000F60  00402821   ADDU A1, V0, ZERO
9D000F64  24062580   ADDIU A2, ZERO, 9600
9D000F68  0F4008B3   JAL UARTSetDataRate
9D000F6C  00000000   NOP
9D000F70  AFC20010   SW V0, 16(S8)
104:                     UARTEnable(UART1, UART_ENABLE_FLAGS(UART_PERIPHERAL | UART_RX | UART_TX));  
9D000F74  00002021   ADDU A0, ZERO, ZERO
9D000F78  24050087   ADDIU A1, ZERO, 135
9D000F7C  0F400853   JAL UARTEnable
9D000F80  00000000   NOP
105:                     printf("pt started: BAUD=%d\n\r",bit_rate);
9D000F84  3C029D00   LUI V0, -25344
9D000F88  2444249C   ADDIU A0, V0, 9372
9D000F8C  8FC50010   LW A1, 16(S8)
9D000F90  0F400984   JAL 0x9D002610
9D000F94  00000000   NOP
106:                     
107:                     // Setuo Timer2 as 1ms counter
108:                     // Enable T2, Use internal clock (PBCLK), Prescalar 1:1
109:                     // Count = 40000000/1000 = 40,000 = 1ms
110:                     OpenTimer2(T2_ON | T2_SOURCE_INT | T2_PS_1_1, PB_FREQ/1000);
9D000F98  3C02BF80   LUI V0, -16512
9D000F9C  AC400800   SW ZERO, 2048(V0)
9D000FA0  3C02BF80   LUI V0, -16512
9D000FA4  AC400810   SW ZERO, 2064(V0)
9D000FA8  3C02BF81   LUI V0, -16511
9D000FAC  8C42F000   LW V0, -4096(V0)
9D000FB0  7C420CC0   EXT V0, V0, 19, 2
9D000FB4  304200FF   ANDI V0, V0, 255
9D000FB8  3C030262   LUI V1, 610
9D000FBC  34635A00   ORI V1, V1, 23040
9D000FC0  00431007   SRAV V0, V1, V0
9D000FC4  3C031062   LUI V1, 4194
9D000FC8  34634DD3   ORI V1, V1, 19923
9D000FCC  00430018   MULT 0, V0, V1
9D000FD0  00001810   MFHI V1
9D000FD4  00031983   SRA V1, V1, 6
9D000FD8  000217C3   SRA V0, V0, 31
9D000FDC  00621023   SUBU V0, V1, V0
9D000FE0  00401821   ADDU V1, V0, ZERO
9D000FE4  3C02BF80   LUI V0, -16512
9D000FE8  AC430820   SW V1, 2080(V0)
9D000FEC  3C02BF80   LUI V0, -16512
9D000FF0  34038000   ORI V1, ZERO, -32768
9D000FF4  AC430808   SW V1, 2056(V0)
111:                     ConfigIntTimer2(T2_INT_ON | T2_INT_PRIOR_2 | T2_INT_SUB_PRIOR_0);
9D000FF8  3C02BF88   LUI V0, -16504
9D000FFC  24030200   ADDIU V1, ZERO, 512
9D001000  AC431034   SW V1, 4148(V0)
9D001004  3C02BF88   LUI V0, -16504
9D001008  2403001C   ADDIU V1, ZERO, 28
9D00100C  AC4310B4   SW V1, 4276(V0)
9D001010  3C02BF88   LUI V0, -16504
9D001014  24030008   ADDIU V1, ZERO, 8
9D001018  AC4310B8   SW V1, 4280(V0)
9D00101C  3C02BF88   LUI V0, -16504
9D001020  24030003   ADDIU V1, ZERO, 3
9D001024  AC4310B4   SW V1, 4276(V0)
9D001028  3C02BF88   LUI V0, -16504
9D00102C  AC4010B8   SW ZERO, 4280(V0)
9D001030  3C02BF88   LUI V0, -16504
9D001034  24030200   ADDIU V1, ZERO, 512
9D001038  AC431064   SW V1, 4196(V0)
9D00103C  3C02BF88   LUI V0, -16504
9D001040  24030200   ADDIU V1, ZERO, 512
9D001044  AC431068   SW V1, 4200(V0)
112:                     mT2ClearIntFlag();
9D001048  3C02BF88   LUI V0, -16504
9D00104C  24030200   ADDIU V1, ZERO, 512
9D001050  AC431034   SW V1, 4148(V0)
113:                     INTEnableSystemMultiVectoredInt();
9D001054  0F4009B2   JAL INTEnableSystemMultiVectoredInt
9D001058  00000000   NOP
114:                     
115:                     // Port A RA0 Pin2 - Microstick ii onboard LED Pin
116:                     ANSELACLR = _PORTA_RA0_MASK;        // Change RA0 from Analog to Digital (0)
9D00105C  3C02BF88   LUI V0, -16504
9D001060  24030001   ADDIU V1, ZERO, 1
9D001064  AC436004   SW V1, 24580(V0)
117:                     PORTACLR = _PORTA_RA0_MASK;         // Clear RA0 
9D001068  3C02BF88   LUI V0, -16504
9D00106C  24030001   ADDIU V1, ZERO, 1
9D001070  AC436024   SW V1, 24612(V0)
118:                     TRISACLR = _PORTA_RA0_MASK;         // Set RA0 to output (0)
9D001074  3C02BF88   LUI V0, -16504
9D001078  24030001   ADDIU V1, ZERO, 1
9D00107C  AC436014   SW V1, 24596(V0)
119:                     
120:                     // Init threads
121:                     PT_INIT(&pt1);
9D001080  A780801C   SH ZERO, -32740(GP)
122:                     PT_INIT(&pt2);
9D001084  A7808020   SH ZERO, -32736(GP)
123:                     
124:                     while (1) {
125:                         PT_SCHEDULE(protothread1(&pt1));
9D001088  2784801C   ADDIU A0, GP, -32740
9D00108C  0F4002C7   JAL protothread1
9D001090  00000000   NOP
126:                         PT_SCHEDULE(protothread2(&pt2));
9D001094  27848020   ADDIU A0, GP, -32736
9D001098  0F4002FC   JAL protothread2
9D00109C  00000000   NOP
127:                     }
9D0010A0  0B400422   J 0x9D001088
9D0010A4  00000000   NOP
128:                 }
---  c:/program files (x86)/microchip/xc32/v1.42/pic32mx/include/lega-c/peripheral/system.h  ------------
1:                   /********************************************************************
2:                   
3:                   	System Library Interface Definition
4:                   	
5:                   	Summary:
6:                   		This file contains the interface definition for the System
7:                   		peripheral library.
8:                   		
9:                   	Description:
10:                  		This library provides functions for configuring the peripheral
11:                  		clock, cache settings, and wait states.  For details on the
12:                  		register and bit settings used by these functions, refer to the
13:                  		PIC32 Family Reference Manual.
14:                  
15:                  
16:                   ********************************************************************/
17:                  //DOM-IGNORE-BEGIN
18:                  /********************************************************************
19:                   * FileName:		System.h
20:                   * Dependencies:
21:                   * Processor:		PIC32
22:                   * Hardware:		N/A
23:                   * Assembler:		N/A
24:                   * Linker:		    N/A
25:                   * Company:		    Microchip Technology Inc.
26:                   *
27:                   * Software License Agreement:
28:                   * The software supplied herewith by Microchip Technology Incorporated
29:                   * (the “Company”) for its PICmicro® Microcontroller is intended and
30:                   * supplied to you, the Company’s customer, for use solely and
31:                   * exclusively on Microchip PICmicro Microcontroller products. The
32:                   * software is owned by the Company and/or its supplier, and is
33:                   * protected under applicable copyright laws. All rights are reserved.
34:                   * Any use in violation of the foregoing restrictions may subject the
35:                   * user to criminal sanctions under applicable laws, as well as to
36:                   * civil liability for the breach of the terms and conditions of this
37:                   * license.
38:                   *
39:                   * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
40:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
41:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
42:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
43:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
44:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
45:                   *
46:                   * $Id: CoreTimer.h,v 1.2 2006/11/03 15:07:21 C12923 Exp $
47:                   * $Name:  $
48:                   ********************************************************************/
49:                  //DOM-IGNORE-END
50:                   
51:                   
52:                  #ifndef _SYSTEM_HEADER_FILE
53:                  #define _SYSTEM_HEADER_FILE
54:                  
55:                  #include <xc.h>
56:                  #include <peripheral/int.h>
57:                  #include <peripheral/pcache.h>
58:                  #include <peripheral/osc.h>
59:                  #include <peripheral/dma.h>
60:                  #include <peripheral/bmx.h>
61:                  #include <peripheral/lock.h>
62:                  #ifdef __cplusplus
63:                  extern "C"
64:                    {
65:                  #endif
66:                  
67:                  /*
68:                  *  WARNING: All the Peripheral Library (PLIB) functions, including those in this file,
69:                  *  will be removed from future releases of MPLAB XC32 C/C++ Compiler.
70:                  *  Please refer to the MPLAB Harmony Libraries for new projects.  For legacy support,
71:                  *  these PLIB Libraries will be available for download from: www.microchip.com/pic32_peripheral_lib
72:                  */
73:                  #ifndef _SUPPRESS_PLIB_WARNING
74:                    #warning The PLIB functions and macros in this file will be removed from the MPLAB XC32 C/C++ Compiler in future releases
75:                  #endif
76:                  
77:                  
78:                  
79:                  #define FLASH_SPEED_HZ          30000000 //Max Flash speed
80:                  #define PB_BUS_MAX_FREQ_HZ      80000000 //Max Peripheral bus speed
81:                  
82:                  /*********************************************************************
83:                   * SYSTEMConfig Flags
84:                   *********************************************************************/
85:                  #define SYS_CFG_WAIT_STATES     0x00000001 //SYSTEMConfig wait states
86:                  #define SYS_CFG_PB_BUS          0x00000002 //SYSTEMConfig pb bus
87:                  #define SYS_CFG_PCACHE          0x00000004 //SYSTEMConfig cache
88:                  #define SYS_CFG_ALL             0xFFFFFFFF //SYSTEMConfig All
89:                  
90:                  /*********************************************************************
91:                   Function:       
92:                  	unsigned int SYSTEMConfigPB(unsigned int sys_clock)
93:                   
94:                   Description:
95:                  	The function sets the PB divider to the optimum value.
96:                   
97:                   PreCondition:    
98:                  	None
99:                   
100:                  Parameters:           
101:                 	sys_clock - system clock in Hz
102:                  
103:                  Returns:          
104:                 	the PB clock frequency in Hz
105:                  
106:                  Side Effects:
107:                 	The PB clock may be changed
108:                 	
109:                  Overview:	    
110:                 	The function sets the PB divider to the optimum value.
111:                  
112:                  Remarks:            
113:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
114:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
115:                  
116:                  Example:
117:                 	<code>
118:                 	SYSTEMConfigPB(72000000);
119:                 	</code>
120:                  ********************************************************************/
121:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigPB(unsigned int sys_clock)
122:                 {
123:                     unsigned int pb_div;
124:                     unsigned int pb_clock;
125:                 
126:                     pb_clock = sys_clock;
9D000D30  8FC20024   LW V0, 36(S8)
9D000D34  AFC20028   SW V0, 40(S8)
127:                 
128:                     if(sys_clock > PB_BUS_MAX_FREQ_HZ)
9D000D38  8FC30024   LW V1, 36(S8)
9D000D3C  3C0204C4   LUI V0, 1220
9D000D40  3442B401   ORI V0, V0, -19455
9D000D44  0062102B   SLTU V0, V1, V0
9D000D48  14400008   BNE V0, ZERO, 0x9D000D6C
9D000D4C  00000000   NOP
129:                     {
130:                         pb_div=OSC_PB_DIV_2;
9D000D50  3C020008   LUI V0, 8
9D000D54  AFC2002C   SW V0, 44(S8)
131:                         pb_clock >>= 1;
9D000D58  8FC20028   LW V0, 40(S8)
9D000D5C  00021042   SRL V0, V0, 1
9D000D60  AFC20028   SW V0, 40(S8)
9D000D64  0B40035C   J 0x9D000D70
9D000D68  00000000   NOP
132:                     }
133:                     else
134:                     {
135:                         pb_div=OSC_PB_DIV_1;
9D000D6C  AFC0002C   SW ZERO, 44(S8)
9D000D70  8FC2002C   LW V0, 44(S8)
9D000D74  AFC20030   SW V0, 48(S8)
136:                     }
137:                 
138:                     OSCSetPBDIV(pb_div);
139:                 
140:                     return pb_clock;
141:                 }
142:                 
143:                 
144:                 /*********************************************************************
145:                   Function:        
146:                 	void SYSTEMConfigWaitStates(unsigned int sys_clock)
147:                  
148:                   Description:
149:                 	The function sets the Flash Wait states to the optimum value.
150:                  
151:                   PreCondition:    
152:                 	None
153:                  
154:                   Parameters:           
155:                 	sys_clock - system clock in Hz
156:                  
157:                   Returns:          
158:                 	None
159:                  
160:                   Side Effects:    
161:                 	The Wait States may be changed  
162:                  
163:                   Remarks:         
164:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
165:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
166:                  
167:                   Example:
168:                 	<code>
169:                 	SYSTEMConfigWaitStates(72000000);
170:                 	</code>
171:                  ********************************************************************/
172:                 extern inline void __attribute__((always_inline)) SYSTEMConfigWaitStates(unsigned int sys_clock)
173:                 {
174:                 #ifdef _PCACHE
175:                     unsigned int wait_states;
176:                     unsigned int int_status;
177:                 #endif
178:                 
179:                 #ifdef _PCACHE
180:                     wait_states = 0;
181:                 
182:                     while(sys_clock > FLASH_SPEED_HZ)
183:                     {
184:                         wait_states++;
185:                         sys_clock -= FLASH_SPEED_HZ;
186:                     }
187:                 
188:                     int_status=INTDisableInterrupts();
189:                     mCheConfigure(wait_states);
190:                     INTRestoreInterrupts(int_status);
191:                 
192:                 #endif
193:                 }
194:                 
195:                 /*********************************************************************
196:                   Function:        
197:                 		unsigned int SYSTEMConfigWaitStatesAndPB(unsigned int sys_clock)
198:                   
199:                   Description:
200:                 	The function sets the PB divider and the Flash Wait states to the optimum value.
201:                  
202:                   PreCondition:    
203:                 	None
204:                  
205:                   Parameters:           
206:                 	sys_clock - system clock in Hz
207:                  
208:                   Returns:          
209:                 	the PB clock frequency in Hz
210:                  
211:                   Side Effects:    
212:                 	The PB clock and wait states may be changed
213:                 
214:                   Remarks:            
215:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
216:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
217:                  
218:                   Example:
219:                 	<code>
220:                 	SYSTEMConfigWaitStatesAndPB(72000000);
221:                 	</code>
222:                  ********************************************************************/
223:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigWaitStatesAndPB(unsigned int sys_clock)
224:                 {
225:                 #ifdef _PCACHE
226:                     unsigned int wait_states;
227:                 #endif
228:                     unsigned int pb_clock;
229:                     unsigned int int_status;
230:                 
231:                     pb_clock = SYSTEMConfigPB(sys_clock);
232:                 
233:                 
234:                     // set the flash wait states based on 1 wait state
235:                     // for every 20 MHz
236:                 #ifdef _PCACHE
237:                     wait_states = 0;
238:                 
239:                     while(sys_clock > FLASH_SPEED_HZ)
240:                     {
241:                         wait_states++;
242:                         sys_clock -= FLASH_SPEED_HZ;
243:                     }
244:                 
245:                     int_status=INTDisableInterrupts();
246:                     mCheConfigure(wait_states);
247:                     INTRestoreInterrupts(int_status);
248:                 
249:                 #endif
250:                 
251:                     return pb_clock;
252:                 }
253:                 /*********************************************************************
254:                   Function:       
255:                 	unsigned int SYSTEMConfigPerformance(unsigned int sys_clock)
256:                  
257:                   Description:
258:                 	The function sets the PB divider, the Flash Wait states and the DRM wait states to the optimum value.
259:                     It also enables the cacheability for the K0 segment.
260:                 	
261:                   PreCondition:    
262:                 	None
263:                  
264:                   Parameters:           
265:                 	sys_clock - system clock in Hz
266:                  
267:                   Output:          
268:                 	the PB clock frequency in Hz
269:                  
270:                   Side Effects:    
271:                 	Sets the PB and Flash Wait states
272:                  	
273:                   Remarks:            
274:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
275:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
276:                  
277:                   Example:
278:                 	<code>
279:                 	SYSTEMConfigPerformance(72000000);
280:                 	</code>
281:                  ********************************************************************/
282:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigPerformance(unsigned int sys_clock)
283:                 {
284:                     // set up the wait states
285:                     unsigned int pb_clk;
286:                 #ifdef _PCACHE
287:                     unsigned int cache_status;
288:                 #endif
289:                     unsigned int int_status;
290:                 
291:                     pb_clk = SYSTEMConfigWaitStatesAndPB(sys_clock);
292:                 
293:                     int_status=INTDisableInterrupts();
294:                 
295:                     mBMXDisableDRMWaitState();
296:                 
297:                 #ifdef _PCACHE
298:                     cache_status = mCheGetCon();
299:                     cache_status |= CHE_CONF_PF_ALL;
300:                     mCheConfigure(cache_status);
301:                     CheKseg0CacheOn();
302:                 #endif
303:                 
304:                     INTRestoreInterrupts(int_status);
305:                 
306:                     return pb_clk;
307:                 
308:                 }
309:                 /*********************************************************************
310:                   Function:       
311:                 	unsigned int SYSTEMConfig(unsigned int sys_clock, unsigned int flags)
312:                  
313:                   Description:
314:                 	The function sets the PB divider, the Flash Wait states or the DRM wait states to the optimum value, 
315:                 	based on the flags selected and on the frequency of the system clock.
316:                     It also enables the cacheability for the K0 segment.
317:                 				   
318:                   PreCondition:    
319:                 	None
320:                  
321:                   Parameters:           
322:                 	sys_clock - system clock frequency in Hz
323:                     flags -
324:                 		*    SYS_CFG_WAIT_STATES  - configure the flash wait states from the system clock
325:                         *    SYS_CFG_PB_BUS       - configure the PB bus from the system clock
326:                         *    SYS_CFG_PCACHE      - configure the pCache (if used)
327:                         *    SYS_CFG_ALL          - configure all based on system clock
328:                  
329:                   Returns:          
330:                 	the PB clock frequency in Hz
331:                  
332:                   Side Effects:    
333:                 	Could change the wait state, pb clock and turn on the pre-fetch buffer and cache. Sets the RAM
334:                     wait state to 0.
335:                   
336:                  
337:                   Remarks:
338:                 	The interrupts are disabled shortly, the DMA is suspended and the system is unlocked while performing the operation.
339:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
340:                  
341:                   Example:
342:                 	<code>
343:                 	SYSTEMConfig(72000000, SYS_CFG_ALL);
344:                 	</code>
345:                  ********************************************************************/
346:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfig(unsigned int sys_clock, unsigned int flags)
347:                 {
348:                     unsigned int pb_clk;
349:                     unsigned int int_status;
350:                 #ifdef _PCACHE
351:                     unsigned int cache_status;
352:                 #endif
353:                 
354:                     int_status=INTDisableInterrupts();
9D000CE8  0F400A39   JAL INTDisableInterrupts
9D000CEC  00000000   NOP
9D000CF0  AFC2001C   SW V0, 28(S8)
355:                 
356:                     mBMXDisableDRMWaitState();
9D000CF4  3C02BF88   LUI V0, -16504
9D000CF8  24030040   ADDIU V1, ZERO, 64
9D000CFC  AC432004   SW V1, 8196(V0)
357:                 
358:                     if(flags & SYS_CFG_WAIT_STATES)
9D000D00  8FC20018   LW V0, 24(S8)
9D000D04  30420001   ANDI V0, V0, 1
9D000D08  10400003   BEQ V0, ZERO, 0x9D000D18
9D000D0C  00000000   NOP
9D000D10  8FC20014   LW V0, 20(S8)
9D000D14  AFC20020   SW V0, 32(S8)
359:                     {
360:                         SYSTEMConfigWaitStates(sys_clock);
361:                     }
362:                 
363:                     if(flags & SYS_CFG_PB_BUS)
9D000D18  8FC20018   LW V0, 24(S8)
9D000D1C  30420002   ANDI V0, V0, 2
9D000D20  10400065   BEQ V0, ZERO, 0x9D000EB8
9D000D24  00000000   NOP
9D000D28  8FC20014   LW V0, 20(S8)
9D000D2C  AFC20024   SW V0, 36(S8)
364:                     {
365:                         SYSTEMConfigPB(sys_clock);
366:                     }
367:                 
368:                 
369:                 #ifdef _PCACHE
370:                     if(flags & SYS_CFG_PCACHE)
371:                     {
372:                         cache_status = mCheGetCon();
373:                         cache_status |= CHE_CONF_PF_ALL;
374:                         mCheConfigure(cache_status);
375:                         CheKseg0CacheOn();
376:                     }
377:                 #endif
378:                 
379:                     pb_clk = sys_clock;
9D000EB8  8FC20014   LW V0, 20(S8)
9D000EBC  AFC20048   SW V0, 72(S8)
380:                     pb_clk >>= OSCCONbits.PBDIV;
9D000EC0  3C02BF81   LUI V0, -16511
9D000EC4  8C42F000   LW V0, -4096(V0)
9D000EC8  7C420CC0   EXT V0, V0, 19, 2
9D000ECC  304200FF   ANDI V0, V0, 255
9D000ED0  8FC30048   LW V1, 72(S8)
9D000ED4  00431006   SRLV V0, V1, V0
9D000ED8  AFC20048   SW V0, 72(S8)
381:                 
382:                     INTRestoreInterrupts(int_status);
9D000EDC  8FC4001C   LW A0, 28(S8)
9D000EE0  0F400A0C   JAL INTRestoreInterrupts
9D000EE4  00000000   NOP
383:                 
384:                     return pb_clk;
385:                 
386:                 }
387:                 #ifdef __cplusplus
388:                   }
389:                 #endif
390:                 #endif
391:                 
---  c:/program files (x86)/microchip/xc32/v1.42/pic32mx/include/lega-c/peripheral/osc.h  ---------------
1:                   /*********************************************************************
2:                    *
3:                    *                  OSC API definitions
4:                    *
5:                    *********************************************************************
6:                    * FileName:        OSC.h
7:                    * Dependencies:
8:                    * Processor:       PIC32
9:                    *
10:                   *
11:                   * Compiler:        MPLAB XC32
12:                   *                  MPLAB IDE
13:                   * Company:         Microchip Technology Inc.
14:                   *
15:                   * Software License Agreement
16:                   *
17:                   * The software supplied herewith by Microchip Technology Incorporated
18:                   * (the “Company”) for its PIC Microcontroller is intended
19:                   * and supplied to you, the Company’s customer, for use solely and
20:                   * exclusively on Microchip PIC Microcontroller products.
21:                   * The software is owned by the Company and/or its supplier, and is
22:                   * protected under applicable copyright laws. All rights are reserved.
23:                   * Any use in violation of the foregoing restrictions may subject the
24:                   * user to criminal sanctions under applicable laws, as well as to
25:                   * civil liability for the breach of the terms and conditions of this
26:                   * license.
27:                   *
28:                   * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
29:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
30:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
31:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
32:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
33:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
34:                   *
35:                   *
36:                   * $Id: OSC.h,v 1.6 2006/10/13 21:24:31 C12532 Exp $
37:                   * $Name:  $
38:                   ********************************************************************/
39:                  
40:                  #ifndef OSC_H_
41:                  #define OSC_H_
42:                  
43:                  #include <xc.h>
44:                  #include <peripheral/lock.h>
45:                  
46:                  /*
47:                  *  WARNING: All the Peripheral Library (PLIB) functions, including those in this file,
48:                  *  will be removed from future releases of MPLAB XC32 C/C++ Compiler.
49:                  *  Please refer to the MPLAB Harmony Libraries for new projects.  For legacy support,
50:                  *  these PLIB Libraries will be available for download from: www.microchip.com/pic32_peripheral_lib
51:                  */
52:                  #ifndef _SUPPRESS_PLIB_WARNING
53:                    #warning The PLIB functions and macros in this file will be removed from the MPLAB XC32 C/C++ Compiler in future releases
54:                  #endif
55:                  
56:                  
57:                  #define _OSC_
58:                  
59:                  /*********************************************************************
60:                   * Function:        OSCConfig(unsigned long int source, unsigned long int mult, unsigned long int post, unsigned long int div)
61:                   *
62:                   * Description:     Sets Osc options and clock source
63:                   *
64:                   * PreCondition:    Interrupts must be disabled and DMA suspended or disabled
65:                   *
66:                   * Inputs:          Clock source, PLL multiplier, PLL postscaler, FRC divisor - see below
67:                   *
68:                   * Output:          None
69:                   *
70:                   * Example:         OSCConfig( OSC_POSC, OSC_PLL_MULT_24, OSC_PLL_POST_256, OSC_FRC_POST_64 )
71:                   *
72:                   * Note:            Forces cpu clock source to FRC(no divisor, no PLL), configures new clock
73:                   *                  source and then switches to the new clock source
74:                   *
75:                   *                  Unused parameters are set to zero/default values.
76:                   ********************************************************************/
77:                  void OSCConfig(unsigned long int source, unsigned long int mult, unsigned long int post, unsigned long int div);
78:                  
79:                      /******************************************************************************
80:                       * Available options for source parameter
81:                       *****************************************************************************/
82:                          // CPU Oscillator modes - values are mutually exclusive
83:                          #define OSC_FRC_DIV     (7 << _OSCCON_NOSC_POSITION)
84:                          #define OSC_FRC_DIV16   (6 << _OSCCON_NOSC_POSITION)
85:                          #define OSC_LPRC        (5 << _OSCCON_NOSC_POSITION)
86:                          #define OSC_SOSC        (4 << _OSCCON_NOSC_POSITION)
87:                          #define OSC_POSC_PLL    (3 << _OSCCON_NOSC_POSITION)
88:                          #define OSC_POSC        (2 << _OSCCON_NOSC_POSITION)
89:                          #define OSC_FRC_PLL     (1 << _OSCCON_NOSC_POSITION)
90:                          #define OSC_FRC         (0 << _OSCCON_NOSC_POSITION)
91:                  
92:                      /******************************************************************************
93:                       * Available options for mult parameter
94:                       *****************************************************************************/
95:                          // CPU PLL multiplier values - values are mutually exclusive
96:                          #define OSC_PLL_MULT_24 (7 << _OSCCON_PLLMULT_POSITION)
97:                          #define OSC_PLL_MULT_21 (6 << _OSCCON_PLLMULT_POSITION)
98:                          #define OSC_PLL_MULT_20 (5 << _OSCCON_PLLMULT_POSITION)
99:                          #define OSC_PLL_MULT_19 (4 << _OSCCON_PLLMULT_POSITION)
100:                         #define OSC_PLL_MULT_18 (3 << _OSCCON_PLLMULT_POSITION)
101:                         #define OSC_PLL_MULT_17 (2 << _OSCCON_PLLMULT_POSITION)
102:                         #define OSC_PLL_MULT_16 (1 << _OSCCON_PLLMULT_POSITION)
103:                         #define OSC_PLL_MULT_15 (0 << _OSCCON_PLLMULT_POSITION)
104:                 
105:                     /******************************************************************************
106:                      * Available options for post parameter
107:                      *****************************************************************************/
108:                         // CPU PLL output divisor values - values are mutuallye exclusive
109:                         #define OSC_PLL_POST_256 (7 << _OSCCON_PLLODIV_POSITION)
110:                         #define OSC_PLL_POST_64  (6 << _OSCCON_PLLODIV_POSITION)
111:                         #define OSC_PLL_POST_32  (5 << _OSCCON_PLLODIV_POSITION)
112:                         #define OSC_PLL_POST_16  (4 << _OSCCON_PLLODIV_POSITION)
113:                         #define OSC_PLL_POST_8   (3 << _OSCCON_PLLODIV_POSITION)
114:                         #define OSC_PLL_POST_4   (2 << _OSCCON_PLLODIV_POSITION)
115:                         #define OSC_PLL_POST_2   (1 << _OSCCON_PLLODIV_POSITION)
116:                         #define OSC_PLL_POST_1   (0 << _OSCCON_PLLODIV_POSITION)
117:                 
118:                     /******************************************************************************
119:                      * Available options for div parameter
120:                      *****************************************************************************/
121:                         // CPU FRC output divisor values - values are mutually exclusive
122:                         #define OSC_FRC_POST_256 (7 << _OSCCON_FRCDIV_POSITION)
123:                         #define OSC_FRC_POST_64  (6 << _OSCCON_FRCDIV_POSITION)
124:                         #define OSC_FRC_POST_32  (5 << _OSCCON_FRCDIV_POSITION)
125:                         #define OSC_FRC_POST_16  (4 << _OSCCON_FRCDIV_POSITION)
126:                         #define OSC_FRC_POST_8   (3 << _OSCCON_FRCDIV_POSITION)
127:                         #define OSC_FRC_POST_4   (2 << _OSCCON_FRCDIV_POSITION)
128:                         #define OSC_FRC_POST_2   (1 << _OSCCON_FRCDIV_POSITION)
129:                         #define OSC_FRC_POST_1   (0 << _OSCCON_FRCDIV_POSITION)
130:                     /***********************************
131:                      * End parameter values
132:                      ************************************/
133:                 
134:                 #if defined(__32MX120F064H__) || \
135:                     defined(__32MX130F128H__) || \
136:                     defined(__32MX130F128L__) || \
137:                     defined(__32MX150F256H__) || \
138:                     defined(__32MX150F256L__) || \
139:                     defined(__32MX170F512H__) || \
140:                     defined(__32MX170F512L__) || \
141:                     defined(__32MX230F128H__) || \
142:                     defined(__32MX230F128L__) || \
143:                     defined(__32MX250F256H__) || \
144:                     defined(__32MX250F256L__) || \
145:                     defined(__32MX270F512H__) || \
146:                     defined(__32MX270F512L__) || \
147:                     defined(__32MX530F128H__) || \
148:                     defined(__32MX530F128L__) || \
149:                     defined(__32MX550F256H__) || \
150:                     defined(__32MX550F256L__) || \
151:                     defined(__32MX570F512H__) || \
152:                     defined(__32MX570F512L__)
153:                   #define NEED_OSCREFCONFIG_FLAGS
154:                 #elif (__PIC32_FEATURE_SET__ >= 100) && (__PIC32_FEATURE_SET__ <= 299)
155:                   #define NEED_OSCREFCONFIG_FLAGS
156:                 #elif (__PIC32_FEATURE_SET__ == 330) || \
157:                       (__PIC32_FEATURE_SET__ == 350) || \
158:                       (__PIC32_FEATURE_SET__ == 370) || \
159:                       (__PIC32_FEATURE_SET__ == 430) || \
160:                       (__PIC32_FEATURE_SET__ == 450) || \
161:                       (__PIC32_FEATURE_SET__ == 470)
162:                   #define NEED_OSCREFCONFIG_FLAGS
163:                 #else
164:                   #undef  NEED_OSCREFCONFIG_FLAGS
165:                 #endif
166:                 
167:                 #if defined( NEED_OSCREFCONFIG_FLAGS )
168:                   // Reference Oscillator Source Select bits - values are mutually exclusive
169:                   #define OSC_REFOCON_REFCLKI     (7 << _REFOCON_ROSEL_POSITION )
170:                   #define OSC_REFOCON_SYSPLL      (7 << _REFOCON_ROSEL_POSITION )
171:                   #define OSC_REFOCON_USBPLL      (6 << _REFOCON_ROSEL_POSITION )
172:                   #define OSC_REFOCON_SOSC        (5 << _REFOCON_ROSEL_POSITION )
173:                   #define OSC_REFOCON_LPRC        (4 << _REFOCON_ROSEL_POSITION )
174:                   #define OSC_REFOCON_FRC         (3 << _REFOCON_ROSEL_POSITION )
175:                   #define OSC_REFOCON_POSC        (2 << _REFOCON_ROSEL_POSITION )
176:                   #define OSC_REFOCON_PBCLK       (1 << _REFOCON_ROSEL_POSITION )
177:                   #define OSC_REFOCON_SYSCLK      (0 << _REFOCON_ROSEL_POSITION )
178:                 
179:                   typedef enum
180:                   {
181:                       OSC_REFOCON_RLSPEN      =(1 << _REFOCON_RSLP_POSITION ) ,
182:                       OSC_REFOCON_OE          =(1 << _REFOCON_OE_POSITION ),
183:                       OSC_REFOCON_SIDLEN      =(1 << _REFOCON_SIDL_POSITION ),
184:                       OSC_REFOCON_ON          =(1 << _REFOCON_ON_POSITION )
185:                   } OSCREFConfigFlags;
186:                 
187:                   void OSCREFConfig(unsigned long int source, OSCREFConfigFlags config, unsigned long int div);
188:                 
189:                   #define mOSCREFOTRIMSet(trim)       (REFOTRIM = (trim << _REFOTRIM_ROTRIM_POSITION))
190:                 
191:                 #endif//defined( NEED_OSCREFCONFIG_FLAGS )
192:                 
193:                 #undef  NEED_OSCREFCONFIG_FLAGS
194:                 
195:                 
196:                 /*********************************************************************
197:                  * Function:    OSCSetPBDIV(unsigned int oscPbDiv)
198:                  *
199:                  * Description: Configures peripheral bus divisor
200:                  *
201:                  * PreCondition: oscPbDiv one of the OSC_PB_DIV_X valid values
202:                  *
203:                  * Inputs:    oscPbDiv - desired PB divider
204:                  *
205:                  * Output:      None
206:                  *
207:                  * Example:   OSCSetPBDIV(  OSC_PB_DIV_8 )
208:                  *
209:                  ********************************************************************/
210:                 extern inline void __attribute__((always_inline)) OSCSetPBDIV(unsigned int oscPbDiv)
211:                 {
212:                     unsigned int dma_status;
213:                     unsigned int int_status;
214:                     __OSCCONbits_t oscBits;
215:                 
216:                     mSYSTEMUnlock(int_status, dma_status);
9D000D78  0F400A39   JAL INTDisableInterrupts
9D000D7C  00000000   NOP
9D000D80  AFC20034   SW V0, 52(S8)
9D000DC8  AFC2003C   SW V0, 60(S8)
9D000DCC  3C02BF81   LUI V0, -16511
9D000DD0  AC40F230   SW ZERO, -3536(V0)
9D000DD4  3C02BF81   LUI V0, -16511
9D000DD8  3C03AA99   LUI V1, -21863
9D000DDC  34636655   ORI V1, V1, 26197
9D000DE0  AC43F230   SW V1, -3536(V0)
9D000DE4  3C02BF81   LUI V0, -16511
9D000DE8  3C035566   LUI V1, 21862
9D000DEC  346399AA   ORI V1, V1, -26198
9D000DF0  AC43F230   SW V1, -3536(V0)
217:                 
218:                     oscBits.w=OSCCON;       // read to be in sync. flush any pending write
9D000DF4  3C02BF81   LUI V0, -16511
9D000DF8  8C42F000   LW V0, -4096(V0)
9D000DFC  AFC2004C   SW V0, 76(S8)
219:                     oscBits.PBDIV=0;
9D000E00  8FC2004C   LW V0, 76(S8)
9D000E04  7C02A4C4   INS V0, ZERO, 19, 2
9D000E08  AFC2004C   SW V0, 76(S8)
220:                     oscBits.w|=oscPbDiv;
9D000E0C  8FC3004C   LW V1, 76(S8)
9D000E10  8FC20030   LW V0, 48(S8)
9D000E14  00621025   OR V0, V1, V0
9D000E18  AFC2004C   SW V0, 76(S8)
221:                     OSCCON=oscBits.w;       // write back
9D000E1C  8FC3004C   LW V1, 76(S8)
9D000E20  3C02BF81   LUI V0, -16511
9D000E24  AC43F000   SW V1, -4096(V0)
222:                     oscBits.w=OSCCON;       // make sure the write occurred before returning from this function
9D000E28  3C02BF81   LUI V0, -16511
9D000E2C  8C42F000   LW V0, -4096(V0)
9D000E30  AFC2004C   SW V0, 76(S8)
223:                 
224:                     mSYSTEMLock(int_status, dma_status);
9D000E34  3C02BF81   LUI V0, -16511
9D000E38  3C033333   LUI V1, 13107
9D000E3C  34633333   ORI V1, V1, 13107
9D000E40  AC43F230   SW V1, -3536(V0)
9D000E44  8FC2003C   LW V0, 60(S8)
9D000E48  AFC20040   SW V0, 64(S8)
9D000EAC  8FC40034   LW A0, 52(S8)
9D000EB0  0F400A0C   JAL INTRestoreInterrupts
9D000EB4  00000000   NOP
225:                 }
226:                 
227:                 #define     mOSCSetPBDIV        OSCSetPBDIV     // backward compatibility
228:                 
229:                 
230:                 
231:                     /******************************************************************************
232:                      * Available options for config parameter
233:                      *****************************************************************************/
234:                         // CPU Peripheral Bus divisor values - values are mutually exclusive
235:                         #define OSC_PB_DIV_8    (3 << _OSCCON_PBDIV_POSITION)
236:                         #define OSC_PB_DIV_4    (2 << _OSCCON_PBDIV_POSITION)
237:                         #define OSC_PB_DIV_2    (1 << _OSCCON_PBDIV_POSITION)
238:                         #define OSC_PB_DIV_1    (0 << _OSCCON_PBDIV_POSITION)
239:                     /***********************************
240:                      * End config parameter values
241:                      ************************************/
242:                 
243:                 
244:                 /*********************************************************************
245:                  * Function:    mOSCGetPBDIV()
246:                  *
247:                  * Description: Reads peripheral bus divisor
248:                  *
249:                  * PreCondition:None
250:                  *
251:                  * Inputs:      None
252:                  *
253:                  * Output:      None
254:                  *
255:                  * Example:     mOSCGetPBDIV()
256:                  *
257:                  ********************************************************************/
258:                 #define mOSCGetPBDIV() (OSCCONbits.PBDIV)
259:                 
260:                 
261:                 /*********************************************************************
262:                  * Function:    mOSCClockFailStatus()
263:                  *
264:                  * Description: Returns Clock Fail status. 1 = clock fail, 0 = no clock fail
265:                  *
266:                  * PreCondition: None
267:                  *
268:                  * Inputs:      None
269:                  *
270:                  * Output:      None
271:                  *
272:                  * Example:     mOSCClockFailStatus()
273:                  *
274:                  ********************************************************************/
275:                 #define mOSCClockFailStatus (OSCCONbits.CF)
276:                 
277:                 
278:                 /*********************************************************************
279:                  * Function:        mOSCEnableSOSC()
280:                  *
281:                  * Description:     Enables the LPRC
282:                  *
283:                  * PreCondition:    Interrupts must be disabled and DMA suspended or disabled
284:                  *
285:                  * Inputs:          None
286:                  *
287:                  * Output:          None
288:                  *
289:                  * Example:         mOSCEnableSOSC()
290:                  *
291:                  ********************************************************************/
292:                 #define mOSCEnableSOSC() mSysUnlockOpLock(OSCCONSET = _OSCCON_SOSCEN_MASK)
293:                 
294:                 
295:                 /*********************************************************************
296:                  * Function:        mOSCDisableSOSC(config)
297:                  *
298:                  * Description:     Disables SOSC
299:                  *
300:                  * PreCondition:    Interrupts must be disabled and DMA suspended or disabled
301:                  *
302:                  * Inputs:          None
303:                  *
304:                  * Output:          None
305:                  *
306:                  * Example:         mOSCDisableSOSC()
307:                  *
308:                  ********************************************************************/
309:                 #define mOSCDisableSOSC() mSysUnlockOpLock(OSCCONCLR = _OSCCON_SOSCEN_MASK)
310:                 
311:                 
312:                 
313:                 #endif
---  c:/program files (x86)/microchip/xc32/v1.42/pic32mx/include/lega-c/peripheral/dma_1xx_2xx.h  -------
1:                   /*********************************************************************
2:                    *
3:                    *                  DMA API definitions
4:                    *
5:                    *********************************************************************
6:                    * FileName:        Dma.h
7:                    * Dependencies:    xc.h
8:                    *                  int.h
9:                    *
10:                   * Processor:       PIC32
11:                   *
12:                   * Compiler:        MPLAB XC32
13:                   *                  MPLAB IDE
14:                   * Company:         Microchip Technology Inc.
15:                   *
16:                   * Software License Agreement
17:                   *
18:                   * The software supplied herewith by Microchip Technology Incorporated
19:                   * (the “Company”) for its PIC32/PIC24F Microcontroller is intended
20:                   * and supplied to you, the Company’s customer, for use solely and
21:                   * exclusively on Microchip PIC32/PIC24F Microcontroller products.
22:                   * The software is owned by the Company and/or its supplier, and is
23:                   * protected under applicable copyright laws. All rights are reserved.
24:                   * Any use in violation of the foregoing restrictions may subject the
25:                   * user to criminal sanctions under applicable laws, as well as to
26:                   * civil liability for the breach of the terms and conditions of this
27:                   * license.
28:                   *
29:                   * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
30:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
31:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
32:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
33:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
34:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
35:                   *
36:                   *
37:                   * $Id: Dma.h,v 1.9 2007/01/17 21:35:46 C12878 Exp $
38:                   * $Name:  $
39:                   *
40:                   ********************************************************************/
41:                  
42:                  #ifndef _DMA_1XX_2XX_H_
43:                  #define _DMA_1XX_2XX_H_
44:                  
45:                  #include <xc.h>
46:                  
47:                  /*
48:                  *  WARNING: All the Peripheral Library (PLIB) functions, including those in this file,
49:                  *  will be removed from future releases of MPLAB XC32 C/C++ Compiler.
50:                  *  Please refer to the MPLAB Harmony Libraries for new projects.  For legacy support,
51:                  *  these PLIB Libraries will be available for download from: www.microchip.com/pic32_peripheral_lib
52:                  */
53:                  #ifndef _SUPPRESS_PLIB_WARNING
54:                    #warning The PLIB functions and macros in this file will be removed from the MPLAB XC32 C/C++ Compiler in future releases
55:                  #endif
56:                  
57:                  
58:                  // DMA definitions
59:                  
60:                  #ifdef _DMAC0
61:                      #define _DMA_CHANNELS       // DMA channels exist
62:                  
63:                  
64:                  // existent DMA channels
65:                      typedef enum
66:                      {
67:                          DMA_CHANNEL0,
68:                      #ifdef _DMAC1
69:                          DMA_CHANNEL1,
70:                      # ifdef _DMAC2
71:                          DMA_CHANNEL2,
72:                      #  ifdef _DMAC3
73:                          DMA_CHANNEL3,
74:                      #  endif// _DMAC3
75:                      # endif // _DMAC2
76:                      #endif  // _DMAC1
77:                          //  add/remove DMA channel as needed here
78:                  
79:                          DMA_CHANNELS    // number of current available channels
80:                      }DmaChannel;
81:                  
82:                  
83:                      // Relative Dma channels priority, between each other
84:                      typedef enum
85:                      {
86:                          DMA_CHN_PRI0,
87:                          DMA_CHN_PRI1,
88:                          DMA_CHN_PRI2,
89:                          DMA_CHN_PRI3
90:                      }DmaChannelPri;
91:                  
92:                  
93:                  
94:                      // high level definitions for the API functions
95:                  
96:                      typedef enum
97:                      {
98:                          DMA_OPEN_DEFAULT = 0,                                   // DMA default operation
99:                          DMA_OPEN_AUTO   = _DCH0CON_CHAEN_MASK,                  // DMA channel is auto enabled
100:                         DMA_OPEN_CHAIN_LOW  = (_DCH0CON_CHCHN_MASK|_DCH0CON_CHCHNS_MASK),   // DMA channel is chained to lower channel
101:                         DMA_OPEN_CHAIN_HI  = (_DCH0CON_CHCHN_MASK),             // DMA channel is chained to higher channel
102:                         DMA_OPEN_DET_EN = _DCH0CON_CHAED_MASK,                  // events detection enabled while channel off
103:                         DMA_OPEN_ENABLE = _DCH0CON_CHEN_MASK,                   // DMA channel is enabled after open
104:                         DMA_OPEN_MATCH  = 0x80000000,                           // DMA channel stops on match
105:                     }DmaOpenFlags;  // flags for the channel open
106:                 
107:                 
108:                     typedef enum
109:                     {
110:                         DMA_EV_ERR =            0x1,        // address error event
111:                         DMA_EV_ABORT =          0x2,        // transfer abort event
112:                         DMA_EV_CELL_DONE =      0x4,        // cell transfer complete event
113:                         DMA_EV_BLOCK_DONE =     0x8,        // block transfer complete event
114:                         DMA_EV_DST_HALF =       0x10,       // destination half event
115:                         DMA_EV_DST_FULL =       0x20,       // destination full event
116:                         DMA_EV_SRC_HALF =       0x40,       // source half event
117:                         DMA_EV_SRC_FULL =       0x80,       // source full event
118:                 
119:                         DMA_EV_ALL_EVNTS=       (DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_CELL_DONE|DMA_EV_BLOCK_DONE|DMA_EV_DST_HALF|
120:                                                     DMA_EV_DST_FULL|DMA_EV_SRC_HALF|DMA_EV_SRC_FULL)                // all available events
121:                     }DmaEvFlags;    // flags for controlling the DMA channel events; Bit fields from the processor header file.
122:                 
123:                 
124:                     typedef enum
125:                     {
126:                         DMA_TXFER_OK,           // the transfer was performed successfully
127:                         DMA_TXFER_ADD_ERR,      // address error while performing the transfer
128:                         DMA_TXFER_ABORT,        // the DMA transfer was aborted
129:                         DMA_TXFER_BC_ERR,       // block complete not set after the DMA transfer performed
130:                         DMA_TXFER_CC_ERR,       // cell complete not set after the DMA transfer performed
131:                         DMA_TXFER_TMO           // DMA transfer timeout
132:                     }DmaTxferRes;       // DMA transfer result
133:                 
134:                     typedef enum
135:                     {
136:                         DMA_WAIT_NOT,       // don't wait for the transfer to complete, return immediately
137:                         DMA_WAIT_CELL,      // wait for the cell transfer to complete, than return
138:                         DMA_WAIT_BLOCK      // wait for the block transfer to complete, than return
139:                     }DmaWaitMode;       // DMA transfer wait mode
140:                 
141:                     typedef enum
142:                     {
143:                         DMA_CHKSUM_CRC,     // LFSR CRC
144:                         DMA_CHKSUM_IP,      // IP Checksum
145:                     }DmaChksumType;     // DMA SFM supported checksum types
146:                 
147:                     typedef enum
148:                     {
149:                         DMA_BITO_MSb,       // MSb first (not reflected)
150:                         DMA_BITO_LSb,       // LSb first (reflected)
151:                     }DmaBitOrder;       // DMA SFM supported bit ordering
152:                 
153:                     typedef enum
154:                     {
155:                         DMA_REORDER_NOT,    // no reordering, destination matches the source
156:                         DMA_REORDER_ENDIAN, // change endianess on word (32 bit) boundaries: LE<->BE
157:                         DMA_REORDER_SWAP_HALF,  // swap half words (16 bit) within word (32 bit)
158:                         DMA_REORDER_SWAP_BYTE,  // swap bytes within half word (16 bit)
159:                     }DmaReorderMode;    // DMA SFM supported re-ordering modes
160:                 
161:                 
162:                     /*********************************************************************
163:                      * Function:        void DmaChnOpen(DmaChannel chn, DmaChannelPri chPri, DmaOpenFlags oFlags)
164:                      *
165:                      * PreCondition:    chPri  - valid channel priority, 0-3
166:                      *
167:                      * Input:           chn    - channel to be configured in the DMA controller
168:                      *                  chPri  - the priority given to the channel, 0-3
169:                      *                  oFlags - orred flags specifying the open mode:
170:                      *                           DMA_OPEN_DEFAULT: DMA default operation mode
171:                      *                           DMA_OPEN_AUTO: DMA channel is auto enabled
172:                      *                           DMA_OPEN_CHAIN_LOW: DMA channel is chained to lower channel
173:                      *                           DMA_OPEN_CHAIN_HI: DMA channel is chained to higher channel
174:                      *                           DMA_OPEN_DET_EN: events detection enabled while channel off
175:                      *                           DMA_OPEN_ENABLE: DMA channel is enabled when opened
176:                      *                           DMA_OPEN_MATCH:    DMA channel stops on match
177:                      *
178:                      *
179:                      *
180:                      * Output:          None
181:                      *
182:                      * Side Effects:    None
183:                      *
184:                      * Overview:        The function opens and configures the selected DMA channel using the supplied user flags and priority.
185:                      *
186:                      * Note:            - This is a high level access function that doesn't give access to all the settings possible for a DMA channel.
187:                      *                  Use the low level functions to address special settings.
188:                      *                  - The channel is turned off, the pending interrupts are cleared, interrupts are disabled.
189:                      *                  After that the channel is configured.
190:                      *                  - After calling this function, the channel should be enabled using DmaChnEnable(chn) call
191:                      *                  if DMA_OPEN_ENABLE flag was not specified.
192:                      *                  - If the CRC is attached to the submitted channel, the CRC append mode will be turned off.
193:                      *                  This way, the transfer will occur correctly together with CRC calculation.
194:                      *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
195:                      *                  User has to call event channel functions to enable the event flags if needed.
196:                      *
197:                      * Example:         DmaChnOpen(DMA_CHANNEL2, DMA_CHN_PRI2, DMA_OPEN_AUTO|DMA_OPEN_MATCH|DMA_OPEN_ENABLE);
198:                      ********************************************************************/
199:                      void           DmaChnOpen(DmaChannel chn, DmaChannelPri chPri, DmaOpenFlags oFlags);
200:                 
201:                     /*********************************************************************
202:                      * Function:        void DmaChnEnable(DmaChannel chn)
203:                      *
204:                      * PreCondition:    None
205:                      *
206:                      * Input:           chn     - channel to be enabled
207:                      *
208:                      * Output:          None
209:                      *
210:                      * Side Effects:    None
211:                      *
212:                      * Overview:        The function enables a previously configured DMA channel.
213:                      *
214:                      * Note:            DmaChnOpen()/DmaChnConfigure() should have been called before.
215:                      *
216:                      * Example:         DmaChnEnable(DMA_CHANNEL3);
217:                      ********************************************************************/
218:                      void           DmaChnEnable(DmaChannel chn);
219:                 
220:                     /*********************************************************************
221:                      * Function:        void DmaChnDisable(DmaChannel chn)
222:                      *
223:                      * PreCondition:    None
224:                      *
225:                      * Input:           chn     - selected channel in the DMA controller
226:                      *
227:                      * Output:          None
228:                      *
229:                      * Side Effects:    None
230:                      *
231:                      * Overview:        The function disables a DMA channel. The channel operation stops.
232:                      *
233:                      * Note:            None.
234:                      *
235:                      * Example:         DmaChnDisable(DMA_CHANNEL3);
236:                      ********************************************************************/
237:                      void           DmaChnDisable(DmaChannel chn);
238:                 
239:                     /*********************************************************************
240:                      * Function:        void DmaChnSetTxfer(DmaChannel chn, const void* vSrcAdd, void* vDstAdd, int srcSize, int dstSize, int cellSize)
241:                      *
242:                      * PreCondition:    chn     - valid DMA channel
243:                      *              - vSrcAdd, vDstAdd  - valid pointers
244:                      *                              - 0 < srcSize <= DmaGetMaxTxferSize()
245:                      *                              - 0 < dstSize <= DmaGetMaxTxferSize()
246:                      *                              - 0 < cellSize <= DmaGetMaxTxferSize()
247:                      *
248:                      * Input:           chn         - DMA channel number
249:                      *                              - vSrcAdd: source of the DMA transfer
250:                      *                              - vDstAdd: destination of the DMA transfer
251:                      *                              - srcSize: source buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped arround
252:                      *                              - dstSize: destination buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped around
253:                      *                              - cellSize: cell transfer size, 1 to DmaGetMaxTxferSize() bytes.
254:                      *
255:                      * Output:          None
256:                      *
257:                      * Side Effects:    None
258:                      *
259:                      * Overview:        The function sets the transfer characteristics for a DMA channel transfer:
260:                      *                  the source and the destination addresses.
261:                      *                  the source and destination lengths
262:                      *                  and the number of bytes transferred per event.
263:                      *
264:                      * Note:            The function clears the existing DMA channel event flags.
265:                      *                  The source to destination byte re-ordering is affected by DmaSfmConfigure(), DmaSfmTxferReorder().
266:                      *
267:                      * Example:         DmaChnSetTxfer(DMA_CHANNEL3, &U2RXREG, dstBuff, 1, 200, 1);
268:                      ********************************************************************/
269:                      void           DmaChnSetTxfer(DmaChannel chn, const void* vSrcAdd, void* vDstAdd, int srcSize, int dstSize, int cellSize);
270:                 
271:                 
272:                     /*********************************************************************
273:                      * Function:        void DmaChnSetSrcAdd(DmaChannel chn, const void* vSrcAdd)
274:                      *
275:                      * PreCondition:    chn     - valid DMA channel
276:                      *
277:                      * Input:           chn     - DMA channel number
278:                      *              - vSrcAdd: source (virtual) of the DMA transfer
279:                      * Output:          None
280:                      *
281:                      * Side Effects:    None
282:                      *
283:                      * Overview:        The function is a helper to set directly the transfer source address.
284:                      *
285:                      * Note:            None.
286:                      *
287:                      * Example:         DmaChnSetSrcAdd(DMA_CHANNEL2, srcBuff+sizeof(srcBuff));
288:                      ********************************************************************/
289:                      void           DmaChnSetSrcAdd(DmaChannel chn, const void* vSrcAdd);
290:                 
291:                     /*********************************************************************
292:                      * Function:        void DmaChnSetDstAdd(DmaChannel chn, void* vDstAdd)
293:                      *
294:                      * PreCondition:    chn     - valid DMA channel
295:                      *
296:                      * Input:           chn         - DMA channel number
297:                      *                              - vDstAdd: destination (virtual) of the DMA transfer
298:                      * Output:          None
299:                      *
300:                      * Side Effects:    None
301:                      *
302:                      * Overview:        The function is a helper to set directly the transfer destination address.
303:                      *
304:                      * Note:            None
305:                      *
306:                      * Example:         DmaChnSetDstAdd(DMA_CHANNEL2, dstBuff+sizeof(dstBuff));
307:                      ********************************************************************/
308:                      void           DmaChnSetDstAdd(DmaChannel chn, void* vDstAdd);
309:                 
310:                     /*********************************************************************
311:                      * Function:        void DmaChnSetMatchPattern(DmaChannel chn, int pattern)
312:                      *
313:                      * PreCondition:    chn - valid DMA channel
314:                      *
315:                      * Input:           chn     - DMA channel number
316:                      *                  pattern -  the match pattern
317:                      *
318:                      * Output:          None
319:                      *
320:                      * Side Effects:    None
321:                      *
322:                      * Overview:        The function sets the curent match pattern for the selected DMA channel.
323:                      *
324:                      * Note:            None.
325:                      *
326:                      * Example:         DmaChnSetMatchPattern(DMA_CHANNEL3, '\r');
327:                      ********************************************************************/
328:                      void           DmaChnSetMatchPattern(DmaChannel chn, int pattern);
329:                 
330:                     /*********************************************************************
331:                      * Function:        int DmaChnGetMatchPattern(DmaChannel chn)
332:                      *
333:                      * PreCondition:    chn - valid DMA channel
334:                      *
335:                      * Input:           chn     - DMA channel number
336:                      *
337:                      * Output:          The channel match pattern.
338:                      *
339:                      * Side Effects:    None
340:                      *
341:                      * Overview:        The function retrieves the curent match pattern for the selected DMA channel.
342:                      *
343:                      * Note:            None.
344:                      *
345:                      * Example:         int pattern=DmaChnGetMatchPattern(DMA_CHANNEL3);
346:                      ********************************************************************/
347:                      int            DmaChnGetMatchPattern(DmaChannel chn);
348:                 
349:                     /*********************************************************************
350:                      * Function:        DmaTxferRes DmaChnStartTxfer(DmaChannel chn, DmaWaitMode wMode, unsigned long retries)
351:                      *
352:                      * PreCondition:    chn - valid DMA channel
353:                      *
354:                      * Input:           chn     - DMA channel number
355:                      *                  wMode   - if DMA_WAIT_NOT, return immediately
356:                      *                          - if DMA_WAIT_CELL, return after the cell transfer complete
357:                      *                          - if DMA_WAIT_BLOCK, return after the whole transfer is done
358:                      *                  retries - retry counter: if transfer not complete after so many retries, return with tmo.
359:                      *                              If 0, wait forever.
360:                      *
361:                      * Output:          DMA_TXFER_OK if not waiting for the transfer completion or if the transfer ended normally,
362:                      *                  an DmaTxferRes error code  otherwise
363:                      *
364:                      * Side Effects:    None
365:                      *
366:                      * Overview:        The function initiates (forces) a DMA transfer for the selected DMA channel.
367:                      *                  The DMA channel is enabled.
368:                      *                  If waiting for the transfer completion needed (user doesn't use an ISR to catch
369:                      *                  this event) the function will periodically query the DMA controller for the
370:                      *                  transfer completion status.
371:                      *                  If DMA_WAIT_BLOCK is specified and multiple cell transfers are needed to complete
372:                      *                  the block transfer than the function will re-force the transfer for each cell.
373:                      *
374:                      * Note:            This function can not ne used when the DMA channel is triggerred
375:                      *                  by hardware interrupt requests.
376:                      *                  This is because the transfers are software forced, theere is no
377:                      *                  wait for the occurrence of the hardware trigger.
378:                      *
379:                      * Example:         DmaChnStartTxfer(DMA_CHANNEL2, DMA_WAIT_BLOCK, 0);
380:                      ********************************************************************/
381:                      DmaTxferRes DmaChnStartTxfer(DmaChannel chn, DmaWaitMode wMode, unsigned long retries);
382:                 
383:                     /*********************************************************************
384:                      * Function:        void DmaChnForceTxfer(DmaChannel chn)
385:                      *
386:                      * PreCondition:    chn - valid DMA channel
387:                      *
388:                      * Input:           chn     - DMA channel number
389:                      *
390:                      * Output:          None
391:                      *
392:                      * Side Effects:    None
393:                      *
394:                      * Overview:        The function forces a DMA transfer to occur for the selected DMA channel.
395:                      *
396:                      * Note:            None.
397:                      *
398:                      * Example:         DmaChnForceTxfer(DMA_CHANNEL3);
399:                      ********************************************************************/
400:                      void           DmaChnForceTxfer(DmaChannel chn);
401:                 
402:                     /*********************************************************************
403:                      * Function:        void DmaChnAbortTxfer(DmaChannel chn)
404:                      *
405:                      * PreCondition:    chn - valid DMA channel
406:                      *
407:                      * Input:           chn     - DMA channel number
408:                      *
409:                      * Output:          None
410:                      *
411:                      * Side Effects:    None
412:                      *
413:                      * Overview:        The function aborts a current undergoing DMA transfer for the selected DMA channel.
414:                      *
415:                      * Note:            None.
416:                      *
417:                      * Example:         DmaChnAbortTxfer(DMA_CHANNEL3);
418:                      ********************************************************************/
419:                      void           DmaChnAbortTxfer(DmaChannel chn);
420:                 
421:                     // High level channel event and interrupt control functions
422:                 
423:                     /*********************************************************************
424:                      * Function:        void DmaChnSetEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags)
425:                      *
426:                      * PreCondition:    chn - valid DMA channel
427:                      *
428:                      * Input:           chn     - DMA channel number
429:                      *                  eFlags  - event flags with the following significance:
430:                      *                              - DMA_EV_ERR: address error event
431:                      *                              - DMA_EV_ABORT: transfer abort event
432:                      *                              - DMA_EV_CELL_DONE: cell transfer complete event
433:                      *                              - DMA_EV_BLOCK_DONE: block transfer complete event
434:                      *                              - DMA_EV_DST_HALF: destination half event
435:                      *                              - DMA_EV_DST_FULL: destination full event
436:                      *                              - DMA_EV_SRC_HALF: source half event
437:                      *                              - DMA_EV_SRC_FULL: source full event
438:                      *                              - DMA_EV_ALL_EVNTS: all of the above flags
439:                      *
440:                      * Output:          None
441:                      *
442:                      * Side Effects:    None
443:                      *
444:                      * Overview:        The function sets the event enable flags for the selected DMA channel.
445:                      *                  Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
446:                      *                  enabled for the selected channel, the other channel event flags won't be touched.
447:                      *
448:                      * Note:            None.
449:                      *
450:                      * Example:         DmaChnSetEvEnableFlags(DMA_CHANNEL3, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
451:                      ********************************************************************/
452:                      void           DmaChnSetEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags);
453:                 
454:                     /*********************************************************************
455:                      * Function:        void DmaChnClrEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags)
456:                      *
457:                      * PreCondition:    chn - valid DMA channel
458:                      *
459:                      * Input:           chn     - DMA channel number
460:                      *                  eFlags  - event flags with the following significance:
461:                      *                              - DMA_EV_ERR: address error event
462:                      *                              - DMA_EV_ABORT: transfer abort event
463:                      *                              - DMA_EV_CELL_DONE: cell transfer complete event
464:                      *                              - DMA_EV_BLOCK_DONE: block transfer complete event
465:                      *                              - DMA_EV_DST_HALF: destination half event
466:                      *                              - DMA_EV_DST_FULL: destination full event
467:                      *                              - DMA_EV_SRC_HALF: source half event
468:                      *                              - DMA_EV_SRC_FULL: source full event
469:                      *                              - DMA_EV_ALL_EVNTS: all of the above flags
470:                      *
471:                      * Output:          None
472:                      *
473:                      * Side Effects:    None
474:                      *
475:                      * Overview:        The function clears the event enable flags for the selected DMA channel.
476:                      *                  Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
477:                      *                  disabled for the selected channel, the other channel event flags won't be touched.
478:                      *
479:                      * Note:            None.
480:                      *
481:                      * Example:         DmaChnClrEvEnableFlags(DMA_CHANNEL3, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
482:                      ********************************************************************/
483:                      void           DmaChnClrEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags);
484:                 
485:                     /*********************************************************************
486:                      * Function:        void DmaChnWriteEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags)
487:                      *
488:                      * PreCondition:    chn - valid DMA channel
489:                      *
490:                      * Input:           chn     - DMA channel number
491:                      *                  eFlags  - event flags with the following significance:
492:                      *                              - DMA_EV_ERR: address error event
493:                      *                              - DMA_EV_ABORT: transfer abort event
494:                      *                              - DMA_EV_CELL_DONE: cell transfer complete event
495:                      *                              - DMA_EV_BLOCK_DONE: block transfer complete event
496:                      *                              - DMA_EV_DST_HALF: destination half event
497:                      *                              - DMA_EV_DST_FULL: destination full event
498:                      *                              - DMA_EV_SRC_HALF: source half event
499:                      *                              - DMA_EV_SRC_FULL: source full event
500:                      *                              - DMA_EV_ALL_EVNTS: all of the above flags
501:                      *
502:                      * Output:          None
503:                      *
504:                      * Side Effects:    None
505:                      *
506:                      * Overview:        The function sets the event enable flags for the selected DMA channel.
507:                      *                  The channel event flags are forced to the eFlags value.
508:                      *
509:                      * Note:            None.
510:                      *
511:                      * Example:         DmaChnWriteEvEnableFlags(DMA_CHANNEL3, DMA_EV_ALL_EVNTS);
512:                      ********************************************************************/
513:                      void           DmaChnWriteEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags);
514:                 
515:                     /*********************************************************************
516:                      * Function:        DmaEvFlags DmaChnGetEvEnableFlags(DmaChannel chn)
517:                      *
518:                      * PreCondition:    chn - valid DMA channel
519:                      *
520:                      * Input:           chn     - DMA channel number
521:                      *
522:                      * Output:          - event flags with the following significance:
523:                      *                      - DMA_EV_ERR: address error event
524:                      *                      - DMA_EV_ABORT: transfer abort event
525:                      *                      - DMA_EV_CELL_DONE: cell transfer complete event
526:                      *                      - DMA_EV_BLOCK_DONE: block transfer complete event
527:                      *                      - DMA_EV_DST_HALF: destination half event
528:                      *                      - DMA_EV_DST_FULL: destination full event
529:                      *                      - DMA_EV_SRC_HALF: source half event
530:                      *                      - DMA_EV_SRC_FULL: source full event
531:                      *                      - DMA_EV_ALL_EVNTS: all of the above flags
532:                      *
533:                      * Side Effects:    None
534:                      *
535:                      * Overview:        The function returns the event enabled flags for the selected DMA channel.
536:                      *
537:                      * Note:            None.
538:                      *
539:                      * Example:         DmaEvFlags enabledFlags=DmaChnGetEvEnableFlags(DMA_CHANNEL3);
540:                      ********************************************************************/
541:                      DmaEvFlags DmaChnGetEvEnableFlags(DmaChannel chn);
542:                 
543:                     /*********************************************************************
544:                      * Function:        void DmaChnClrEvFlags(DmaChannel chn, DmaEvFlags eFlags)
545:                      *
546:                      * PreCondition:    chn - valid DMA channel
547:                      *
548:                      * Input:           chn     - DMA channel number
549:                      *                  eFlags  - event flags with the following significance:
550:                      *                              - DMA_EV_ERR: address error event
551:                      *                              - DMA_EV_ABORT: transfer abort event
552:                      *                              - DMA_EV_CELL_DONE: cell transfer complete event
553:                      *                              - DMA_EV_BLOCK_DONE: block transfer complete event
554:                      *                              - DMA_EV_DST_HALF: destination half event
555:                      *                              - DMA_EV_DST_FULL: destination full event
556:                      *                              - DMA_EV_SRC_HALF: source half event
557:                      *                              - DMA_EV_SRC_FULL: source full event
558:                      *                              - DMA_EV_ALL_EVNTS: all of the above flags
559:                      *
560:                      * Output:          None
561:                      *
562:                      * Side Effects:    None
563:                      *
564:                      * Overview:        The function clears the event flags for the selected DMA channel.
565:                      *                  Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
566:                      *                  cleared for the selected channel, the other channel event flags won't be touched.
567:                      *
568:                      * Note:            None.
569:                      *
570:                      * Example:         DmaChnClrEvFlags(DMA_CHANNEL3, DMA_EV_ALL_EVNTS);
571:                      ********************************************************************/
572:                      void           DmaChnClrEvFlags(DmaChannel chn, DmaEvFlags eFlags);
573:                 
574:                     /*********************************************************************
575:                      * Function:        DmaEvFlags DmaChnGetEvFlags(DmaChannel chn)
576:                      *
577:                      * PreCondition:    chn - valid DMA channel
578:                      *
579:                      * Input:           chn     - DMA channel number
580:                      *
581:                      * Output:          event flags with the following significance:
582:                      *                      - DMA_EV_ERR: address error event
583:                      *                      - DMA_EV_ABORT: transfer abort event
584:                      *                      - DMA_EV_CELL_DONE: cell transfer complete event
585:                      *                      - DMA_EV_BLOCK_DONE: block transfer complete event
586:                      *                      - DMA_EV_DST_HALF: destination half event
587:                      *                      - DMA_EV_DST_FULL: destination full event
588:                      *                      - DMA_EV_SRC_HALF: source half event
589:                      *                      - DMA_EV_SRC_FULL: source full event
590:                      *                      - DMA_EV_ALL_EVNTS: all of the above flags
591:                      *
592:                      * Side Effects:    None
593:                      *
594:                      * Overview:        The function returns the event flags for the selected DMA channel.
595:                      *
596:                      * Note:            None.
597:                      *
598:                      * Example:         DmaEvFlags intSetFlags=DmaChnGetEvFlags(DMA_CHANNEL3);
599:                      ********************************************************************/
600:                      DmaEvFlags DmaChnGetEvFlags(DmaChannel chn);
601:                 
602:                 
603:                     // high level helpers for fast strcpy/memcpy transfers
604:                 
605:                     /*********************************************************************
606:                      * Function:        DmaTxferRes DmaChnMemcpy(void* s1, const void* s2, int n, DmaChannel chn, DmaChannelPri chPri)
607:                      *
608:                      * PreCondition:    chn     - a valid DMA channel
609:                      *                  s1, s2  - valid memory pointers
610:                      *                  n>0, n<=DmaGetMaxTxferSize()
611:                      *
612:                      * Input:           s1      - destination pointer
613:                      *                  s2      - source pointer
614:                      *                  n       - number of bytes to transfer
615:                      *                  chn     - the DMA channel to perform the transfer
616:                      *                  chPri   - the desired channel priority
617:                      *
618:                      * Output:          DMA_TXFER_OK if the transfer ended normally,
619:                      *                  an DmaTxferRes error code  otherwise
620:                      *
621:                      * Side Effects:    None
622:                      *
623:                      * Overview:        The function configures a DMA channel for a fast memory transfer.
624:                      *          Then it copies one block of memory from source to destination.
625:                      *
626:                      *
627:                      * Note:            - If the SFM is attached to the submitted channel, the SFM append mode will be turned off.
628:                      *                    This way, the transfer will occur correctly together with checksum calculation.
629:                      *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
630:                      *                  - Multiple channels could be opened to perform fast memory transfers, if necessary.
631:                      *                  - The function clears the suspend state and resumes the operation of the DMA controller.
632:                      *                  - The source to destination byte re-ordering is affected by DmaSfmConfigure(), DmaSfmTxferReorder().
633:                      *
634:                      * Example:     res=DmaChnMemcpy(pDst, pSrc, buffSz, DMA_CHANNEL0, DMA_CHN_PRI3);
635:                      ********************************************************************/
636:                      DmaTxferRes    DmaChnMemcpy(void* s1, const void* s2, int n, DmaChannel chn, DmaChannelPri chPri);
637:                 
638:                     /*********************************************************************
639:                      * Function:        DmaTxferRes DmaChnStrcpy(char* s1, const char* s2, DmaChannel chn, DmaChannelPri chPri)
640:                      *
641:                      * PreCondition:    chn     - a valid DMA channel
642:                      *                  s1, s2  - valid memory pointers
643:                      *
644:                      * Input:           s1      - destination pointer
645:                      *                  s2      - source pointer
646:                      *                  chn     - the DMA channel to perform the transfer
647:                      *                  chPri   - the desired channel priority
648:                      *
649:                      * Output:          DMA_TXFER_OK if the transfer ended normally,
650:                      *                  an DmaTxferRes error code  otherwise
651:                      *
652:                      * Side Effects:    None
653:                      *
654:                      * Overview:        The function configures a DMA channel for a fast memory transfer.
655:                      *          Then it copies one zero terminated string from source to destination.
656:                      *
657:                      *
658:                      * Note:            - If the SFM is attached to the submitted channel, the SFM append mode will be turned off.
659:                      *                    This way, the transfer will occur correctly together with checksum calculation.
660:                      *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
661:                      *                  - Multiple channels could be opened to perform fast memory transfers, if necessary.
662:                      *                  - The function clears the suspend state and resumes the operation of the DMA controller.
663:                      *                  - The source to destination byte re-ordering is affected by DmaSfmConfigure(), DmaSfmTxferReorder().
664:                      *
665:                      *
666:                      * Example:     res=DmaChnStrcpy(str1, str2, DMA_CHANNEL1, DMA_CHN_PRI3);
667:                      *********************************************************************/
668:                      DmaTxferRes    DmaChnStrcpy(char* s1, const char* s2, DmaChannel chn, DmaChannelPri chPri);
669:                 
670:                     /*********************************************************************
671:                      * Function:        DmaTxferRes DmaChnStrncpy(char* s1, const char* s2, int n, DmaChannel chn, DmaChannelPri chPri)
672:                      *
673:                      * PreCondition:    chn     - a valid DMA channel
674:                      *              - s1, s2    - valid memory pointers
675:                      *                              - 0 < n <= DmaGetMaxTxferSize()
676:                      *
677:                      * Input:           s1      - destination pointer
678:                      *                  s2      - source pointer
679:                      *                  n   - max number of bytes to transfer
680:                      *                  chn     - the DMA channel to perform the transfer
681:                      *                  chPri   - the desired channel priority
682:                      *
683:                      * Output:          DMA_TXFER_OK if the transfer ended normally,
684:                      *                  an DmaTxferRes error code  otherwise
685:                      *
686:                      * Side Effects:    None
687:                      *
688:                      * Overview:        The function configures a DMA channel for a fast memory transfer.
689:                      *          Then it copies one zero terminated string from source to destination.
690:                      *          It copies no more than n characters from s2.
691:                      *
692:                      *
693:                      * Note:            - If the SFM is attached to the submitted channel, the SFM append mode will be turned off.
694:                      *                    This way, the transfer will occur correctly together with checksum calculation.
695:                      *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
696:                      *                  - Multiple channels could be opened to perform fast memory transfers, if necessary.
697:                      *                  - The function clears the suspend state and resumes the operation of the DMA controller.
698:                      *                  - The source to destination byte re-ordering is affected by DmaSfmConfigure(), DmaSfmTxferReorder().
699:                      *
700:                      *
701:                      * Example:     res=DmaChnStrncpy(str1, str2, MAX_STR_LEN, DMA_CHANNEL1, DMA_CHN_PRI3);
702:                      ********************************************************************/
703:                      DmaTxferRes DmaChnStrncpy(char* s1, const char* s2, int n, DmaChannel chn, DmaChannelPri chPri);
704:                 
705:                     /*********************************************************************
706:                      * Function:        DmaTxferRes DmaChnMemCrc(void* d, const void* s, int n, DmaChannel chn, DmaChannelPri chPri)
707:                      *
708:                      * PreCondition:    chn    - a valid DMA channel
709:                      *                  d, s   - valid memory pointer
710:                      *                  n>0, n<=DmaGetMaxTxferSize()
711:                      *
712:                      * Input:           d     - address where to deposit the result
713:                      *                  s     - source buffer pointer
714:                      *                  n     - number of bytes in the pointer
715:                      *                  chn   - the DMA channel to use
716:                      *                  chPri - the desired channel priority
717:                      *
718:                      * Output:          DMA_TXFER_OK if the transfer ended normally,
719:                      *                  an DmaTxferRes error code  otherwise
720:                      *
721:                      * Side Effects:    None
722:                      *
723:                      * Overview:        The function is a helper that calculates the CRC of a memory block.
724:                      *                  The function configures the DMA channel for a fast memory transfer and calculates the CRC.
725:                      *
726:                      *
727:                      * Note:            - The CRC generator must have been previously configured using DmaSfmCrcConfigure()
728:                      *                  - No transfer is done, just the CRC is calculated.
729:                      *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
730:                      *                  - Append mode is enabled and the data transfer re-ordering is disabled (illegal combination, see DmaSfmTxferReorder()).
731:                      *                  - The checksum type is switched to CRC.
732:                      *                  - The way the data is fed into the checksum calculation block is affected by DmaSfmConfigure().
733:                      *
734:                      * Example:          int myCrc; DmaChnMemCrc(&myCrc, srcBuff, sizeof(srcBuff), DMA_CHANNEL2, DMA_CHN_PRI3);
735:                      ********************************************************************/
736:                      DmaTxferRes    DmaChnMemCrc(void* d, const void* s, int n, DmaChannel chn, DmaChannelPri chPri);
737:                 
738:                     /*********************************************************************
739:                      * Function:        DmaTxferRes DmaChnMemChecksum(void* d, const void* s, int n, DmaChannel chn, DmaChannelPri chPri)
740:                      *
741:                      * PreCondition:    chn    - a valid DMA channel
742:                      *                  d, s   - valid memory pointer
743:                      *                  n>0, n<=DmaGetMaxTxferSize()
744:                      *
745:                      * Input:           d     - address where to deposit the result
746:                      *                  s     - source buffer pointer
747:                      *                  n     - number of bytes in the pointer
748:                      *                  chn   - the DMA channel to use
749:                      *                  chPri - the desired channel priority
750:                      *
751:                      * Output:          DMA_TXFER_OK if the transfer ended normally,
752:                      *                  an DmaTxferRes error code  otherwise
753:                      *
754:                      * Side Effects:    None
755:                      *
756:                      * Overview:        The function is a helper that calculates the IP checksum of a memory block.
757:                      *                  The function configures the DMA channel for a fast memory transfer and calculates the IP checksum.
758:                      *
759:                      *
760:                      * Note:            - The checksum generator must have been previously seeded using DmaSfmSetSeed()
761:                      *                  - No transfer is done, just the checksum is calculated.
762:                      *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
763:                      *                  - Append mode is enabled and the data transfer re-ordering is disabled (illegal combination, see DmaSfmTxferReorder()).
764:                      *                  - The checksum type is switched to IP checksum.
765:                      *                  - The way the data is fed into the checksum calculation block is affected by DmaSfmConfigure().
766:                      *
767:                      * Example:          int myChecksum; DmaChnMemChecksum(&myChecksum, srcBuff, sizeof(srcBuff), DMA_CHANNEL1, DMA_CHN_PRI3);
768:                      ********************************************************************/
769:                      DmaTxferRes    DmaChnMemChecksum(void* d, const void* s, int n, DmaChannel chn, DmaChannelPri chPri);
770:                 
771:                     // High level Special Function Module (SFM) functions
772:                 
773:                     /*********************************************************************
774:                      * Function:        void DmaSfmConfigure(DmaChksumType cType, DmaBitOrder bitO, DmaReorderMode rMode)
775:                      *
776:                      * PreCondition:    cType, bitO, rMode - valid values
777:                      *
778:                      * Input:           cType - checksum type to be calculated: CRC or IP Checksum
779:                      *                  bitO  - the bit order to be used MSb or LSb first
780:                      *                  rMode - the reordering mode of the bytes when calculating the checksum
781:                      *
782:                      * Output:          None
783:                      *
784:                      * Side Effects:    Whenever the Transfer re-ordering is enabled the rMode setting will influence the destination data layout
785:                      *
786:                      * Overview:        The function configures the SFM module by setting the parameters that define the behavior:
787:                      *                      - the type of the checksum to be calculated (either CRC or IP checksum are supported)
788:                      *                      - the bit ordering (how a specific byte is used in the checksum calculation: MSb or LSb first)
789:                      *                      - the data re-ordering (how bytes are re-ordered before calculating the checksum).
790:                      *                      All these values affect the way the checksum is calculated.
791:                      *
792:                      * Note:            None
793:                      *
794:                      * Example:         DmaSfmConfigure(DMA_CHKSUM_CRC, DMA_BITO_LSb, DMA_REORDER_ENDIAN);
795:                      ********************************************************************/
796:                     extern __inline__ void __attribute__((always_inline)) DmaSfmConfigure(DmaChksumType cType, DmaBitOrder bitO, DmaReorderMode rMode)
797:                     {
798:                         DCRCCONCLR=_DCRCCON_CRCTYP_MASK|_DCRCCON_BITO_MASK|_DCRCCON_BYTO_MASK;
799:                         DCRCCONSET=(cType<<_DCRCCON_CRCTYP_POSITION)|(bitO<<_DCRCCON_BITO_POSITION)|(rMode<<_DCRCCON_BYTO_POSITION);
800:                     }
801:                 
802:                     /*********************************************************************
803:                      * Function:        void DmaSfmTxferReorder(int enable)
804:                      *
805:                      * PreCondition:    None
806:                      *
807:                      * Input:           enable - boolean to enable/disable the re-ordering of the data transfer
808:                      *
809:                      * Output:          None
810:                      *
811:                      * Side Effects:    None
812:                      *
813:                      * Overview:        The function configures the data transfer re-ordering of the SFM module.
814:                      *                  If the re-ordering is enabled, the data is read from the source, re-ordered accordingly and then written to the destination.
815:                      *                  Otherwise the data is written to the destination un-modified.
816:                      *                  The re-ordering is the one specified by the DmaReorderMode parameter in the DmaSfmConfigure() call.
817:                      *
818:                      *
819:                      * Note:            - The data transfer re-ordering should be used only for normal (background mode) data transfers.
820:                      *                  - In append mode the data transfer re-ordering should not be enabled (undefined behavior)!
821:                      *                  - Whenever the data re-ordering is enabled, the transfer should be aligned at both ends (source and destination).
822:                      *                    Un-aligned transfers are not supported (undefined behavior)!
823:                      *
824:                      * Example:         DmaSfmTxferReorder();
825:                      ********************************************************************/
826:                     extern __inline__ void __attribute__((always_inline)) DmaSfmTxferReorder(int enable)
827:                     {
828:                         DCRCCONCLR=_DCRCCON_WBO_MASK;
829:                         DCRCCONSET=(enable<<_DCRCCON_WBO_POSITION);
830:                     }
831:                 
832:                 
833:                      /*********************************************************************
834:                      * Function:        void DmaSfmCrcConfigure(unsigned int polynomial, int pLen, unsigned int seed)
835:                      *
836:                      * PreCondition:    pLen   - valid polynomial length within 1-32
837:                      *
838:                      * Input:           polynomial  - the layout of the CRC generator
839:                      *                  pLen        - the length of the CRC generator polynomial
840:                      *                  seed        - the initial seed of the CRC generator
841:                      *
842:                      * Output:          None
843:                      *
844:                      * Side Effects:    None
845:                      *
846:                      * Overview:        The function configures the SFM CRC module by setting the parameters that define the generator polynomial:
847:                      *                  - the length of the CRC generator polynomial, pLen;
848:                      *                  - the function sets the layout of the shift stages that take place in the CRC generation.
849:                      *                    Setting a bit to 1 enables the XOR input from the MSb (pLen bit) to the selected stage in the shift register.
850:                      *                    If bit is cleared, the selected shift stage gets data directly from the previous stage in the shift register.
851:                      *                    Note that in a proper CRC polynomial, both the most significant bit (MSb) and least significant bit(LSb)
852:                      *                    are always a '1'. Considering the generator polynomial: X^16+X^15+X^2+1, the value to be written as
853:                      *                    feedback should be 0x8005, or 0x8004, but not 0x018005;
854:                      *                  - the function sets the seed of the CRC generator. This is the initial data present in the
855:                      *                   CRC shift register before the CRC calculation begins. A good initial value is usually 0xffffffff.
856:                      *
857:                      * Note:            - Bit 0 of the generator polynomial is always XOR'ed.
858:                      *                  - When the append mode is set, the attached DMA channel has to have destination size <=4.
859:                      *                    Upon the transfer completion the calculated CRC is stored at the destination address.
860:                      *                  - When append mode is cleared, the DMA transfer occurs normally, and the CRC value is available using
861:                      *                    the CrcResult() function.
862:                      *                  - The CRC module should be configured before enabled.
863:                      *                  - These settings are relevant only when the SFM is configured for the CRC type of checksum.
864:                      *                  - The checksum register is the same for CRC or IP checksum mode. Therefore, this function changes also the seed for the IP checksum.
865:                      *                  - The way the data is fed into the checksum calculation block and the type of the checksum performed is affected by DmaSfmConfigure().
866:                      *
867:                      * Example:         DmaSfmCrcConfigure(0x04c11db7, 32, 0xffffffff);
868:                      ********************************************************************/
869:                     extern __inline__ void __attribute__((always_inline)) DmaSfmCrcConfigure(unsigned int polynomial, int pLen, unsigned int seed)
870:                     {
871:                         DCRCCONCLR=_DCRCCON_PLEN_MASK;
872:                         DCRCCONSET=(pLen-1)<<_DCRCCON_PLEN_POSITION;
873:                         DCRCDATA=seed;
874:                         DCRCXOR=polynomial;
875:                     }
876:                 
877:                     #define DmaCrcConfigure DmaSfmCrcConfigure  // PIC32_3xx backward compatibility name
878:                 
879:                 
880:                     /*********************************************************************
881:                      * Function:        void DmaSfmAttachChannel(DmaChannel chn, int appendMode)
882:                      *
883:                      * PreCondition:    chn    - valid DMA channel
884:                      *
885:                      * Input:           chn         - the DMA channel to be attached to the checksum module.
886:                      *                  appendMode  - if TRUE the data passed to the checksum generator is not transferred to destination
887:                      *                                but it's written to the destination address when the block transfer is complete.
888:                      *                              - if FALSE the data is transferred normally while the checksum is calculated.
889:                      *                                The checksum will be available using the DmaSfmChecksum function.
890:                      *
891:                      * Output:          None
892:                      *
893:                      * Side Effects:    None
894:                      *
895:                      * Overview:        The function attaches the SFM checksum module to a DMA channel and enables the checksum generator.
896:                      *                  From now on, all the DMA traffic is directed to the SFM checksum generator. Once the DMA block transfer
897:                      *                  is complete, the checksum result is available in the checksum data register.
898:                      *                  If append mode is enabled, no data transfer takes place but the checksum result will be deposited at the DMA destination address.
899:                 
900:                      *
901:                      * Note:            If append mode is enabled the data transfer re-ordering is disabled (illegal combination, see DmaSfmTxferReorder()).
902:                      *
903:                      * Example:         DmaSfmAttachChannel(DMA_CHANNEL0, TRUE);
904:                      ********************************************************************/
905:                     void            DmaSfmAttachChannel(DmaChannel chn, int appendMode);
906:                     #define         CrcAttachChannel    DmaSfmAttachChannel     // PIC32_3xx backward compatibility name
907:                 
908:                     /*********************************************************************
909:                      * Function:        unsigned int DmaSfmChecksum(void)
910:                      *
911:                      * PreCondition:    None
912:                      *
913:                      * Input:           None
914:                      *
915:                      * Output:          the current value of the checksum generator.
916:                      *
917:                      * Side Effects:    None
918:                      *
919:                      * Overview:        The function returns the calculated checksum value.
920:                      *
921:                      * Note:            - The function returns the valid checksum result. The masking out the unused MSbits in the checksum register is done by the hardware.
922:                      *                  - The way the data is fed into the checksum calculation block and the type of the checksum performed is affected by DmaSfmConfigure().
923:                      *
924:                      * Example:         unsigned int myChk=DmaSfmChecksum();
925:                      ********************************************************************/
926:                     extern __inline__ int __attribute__((always_inline)) DmaSfmChecksum(void)
927:                     {
928:                         return DCRCDATA;
929:                     }
930:                     #define     CrcResult   DmaSfmChecksum      // PIC32_3xx backward compatibility name
931:                     #define     DmaCrcGetValue  DmaSfmChecksum      // PIC32_3xx backward compatibility name
932:                 
933:                 
934:                     /*********************************************************************
935:                      * Function:        void DmaSfmSetSeed(unsigned int seed)
936:                      *
937:                      * PreCondition:    None
938:                      *
939:                      * Input:           seed    - the initial seed of the checksum generator
940:                      *
941:                      * Output:          None
942:                      *
943:                      * Side Effects:    None
944:                      *
945:                      * Overview:        The function sets the seed of the checksum generator. This is the initial data present in the
946:                      *                  CRC shift register or the IP checksum calculator before the actual transfer/calculation begins.
947:                      *
948:                      * Note:            When the SFM is configured for IP checksum mode, only the least significant 16 bits are relevant.
949:                      *
950:                      * Example:         DmaSfmSetSeed(0xffffffff);
951:                      ********************************************************************/
952:                     extern __inline__ void __attribute__((always_inline)) DmaSfmSetSeed(unsigned int seed)
953:                     {
954:                         DCRCDATA=seed;
955:                     }
956:                     #define     DmaCrcSetSeed   DmaSfmSetSeed       // PIC32_3xx backward compatibility name
957:                 
958:                 
959:                 /*********************  end of high level functions ****************************************/
960:                 
961:                     // low level definitions for the API functions
962:                 
963:                 
964:                     typedef struct
965:                     {
966:                         union
967:                         {
968:                             struct
969:                             {
970:                                 unsigned int chn:   3;      // last active DMA channel
971:                                 unsigned int rdOp:  1;      // last DMA operation, read if 1, write if 0
972:                             };
973:                             unsigned int    w;                      // word access
974:                         }lastAccess;
975:                         void*   lastAddress;        // most recent DMA address
976:                     }DmaStatus;         // DMA controller status
977:                 
978:                     typedef enum
979:                     {
980:                         DMA_GFLG_SUSPEND =  _DMACON_SUSPEND_MASK,   // suspend DMA controller operation
981:                         DMA_GFLG_ON =       _DMACON_ON_MASK,        // DMA module enabled/desabled
982:                         //
983:                         DMA_GFLG_ALL_FLAGS= DMA_GFLG_SUSPEND|DMA_GFLG_ON        // all flags
984:                     }DmaGlblFlags;  // flags for controlling global DMA controller behavior. From processor header file.
985:                 
986:                 
987:                 
988:                 
989:                     typedef enum
990:                     {
991:                         DMA_EV_ABORT_IRQ_EN =       _DCH0ECON_AIRQEN_MASK,
992:                         DMA_EV_START_IRQ_EN =       _DCH0ECON_SIRQEN_MASK,
993:                         // use DMA_EV_START_IRQ() and DMA_EV_ABORT_IRQ() below for selecting
994:                         // the start and abort IRQ signals
995:                         DMA_EV_MATCH_EN =           _DCH0ECON_PATEN_MASK,
996:                 
997:                 
998:                         // compiler use only field
999:                         _DMA_EV_MAX_MASK =     _DCH0ECON_CHAIRQ_MASK,
1000:                    }DmaEvCtrlFlags;    // DMA channel event control fields accessibile as flags
1001:                    // also part of DmaEvCtrlFlags:
1002:                    #define DMA_EV_START_IRQ(irq)   (DMA_EV_START_IRQ_EN | ((irq)<<_DCH0ECON_CHSIRQ_POSITION))  // NOTE: irq has to be a symbol from the processor header file
1003:                    #define DMA_EV_ABORT_IRQ(irq)   (DMA_EV_ABORT_IRQ_EN | ((irq)<<_DCH0ECON_CHAIRQ_POSITION))  // NOTE: irq has to be a symbol from the processor header file
1004:                
1005:                    // DMA channel event control as a structure:
1006:                    #define DmaEvCtrl   __DCH0ECONbits_t
1007:                
1008:                
1009:                
1010:                
1011:                    typedef enum
1012:                    {
1013:                        DMA_CTL_AUTO_EN =       _DCH0CON_CHAEN_MASK,
1014:                        DMA_CTL_CHAIN_EN =      _DCH0CON_CHCHN_MASK,
1015:                        DMA_CTL_DET_EN =        _DCH0CON_CHAED_MASK,
1016:                        DMA_CTL_CHN_EN =        _DCH0CON_CHEN_MASK,
1017:                        DMA_CTL_CHAIN_DIR =     _DCH0CON_CHCHNS_MASK,
1018:                        // use the DMA_CTL_PRI() below for selecting the DMA
1019:                        // channel priority
1020:                    }DmaChnCtrlFlags;   // controlling the DMA channel with flags
1021:                    // also part of DmaChnCtrlFlags:
1022:                    #define DMA_CTL_PRI(pri)    ((pri)&_DCH0CON_CHPRI_MASK) // DMA Control channel priority
1023:                
1024:                    // DMA channel control as a structure:
1025:                    #define DmaChnCtrl      __DCH0CONbits_t
1026:                
1027:                    typedef struct
1028:                    {
1029:                        void*   vSrcAdd;        // source of the DMA transfer, virtual
1030:                        void*   vDstAdd;        // destination of the DMA transfer, virtual
1031:                        int srcSize;        // source buffer size, 1 to DmaGetMaxTxferSize() bytes. Wrapped around.
1032:                        int dstSize;        // destination buffer size, 1 to DmaGetMaxTxferSize() bytes. Wrapped around.
1033:                        int cellSize;       // no of bytes txferred per event, 1 to DmaGetMaxTxferSize().
1034:                    }DmaTxferCtrl;      // transfer setting: the transfer source, destination addresses and size, cell size
1035:                
1036:                
1037:                    /********************** low level DMA channel functions *******************************/
1038:                
1039:                
1040:                
1041:                    // Global DMA controller functions
1042:                
1043:                    /*********************************************************************
1044:                     * Function:        void DmaEnable(int enable)
1045:                     *
1046:                     * PreCondition:    None
1047:                     *
1048:                     * Input:           enable - boolean to enable/disable the DMA controller
1049:                     *
1050:                     * Output:          None
1051:                     *
1052:                     * Side Effects:    None
1053:                     *
1054:                     * Overview:       The function enables/disables the DMA controller.
1055:                     *
1056:                     * Note:           None.
1057:                     *
1058:                     * Example:        DmaEnable(1);
1059:                     ********************************************************************/
1060:                    extern __inline__ void __attribute__((always_inline)) DmaEnable(int enable)
1061:                    {
1062:                        if(enable)
1063:                        {
1064:                            DMACONSET=_DMACON_ON_MASK;
1065:                        }
1066:                        else
1067:                        {
1068:                            DMACONCLR=_DMACON_ON_MASK;
1069:                            while(DMACONbits.ON);       // wait to take effect
1070:                        }
1071:                    }
1072:                
1073:                    /*********************************************************************
1074:                     * Function:        void DmaReset(void)
1075:                     *
1076:                     * PreCondition:    None
1077:                     *
1078:                     * Input:       None
1079:                     *
1080:                     * Output:          None
1081:                     *
1082:                     * Side Effects:    None
1083:                     *
1084:                     * Overview:        The function resets the DMA controller.
1085:                     *
1086:                     * Note:            None.
1087:                     *
1088:                     * Example:        DmaReset();
1089:                     ********************************************************************/
1090:                    #define            DmaReset()   DmaEnable(0)
1091:                
1092:                
1093:                    /*********************************************************************
1094:                     * Function:        int DmaSuspend(void)
1095:                     *
1096:                     * PreCondition:    None
1097:                     *
1098:                     * Input:       None
1099:                     *
1100:                     * Output:          true if the DMA was previously suspended, false otherwise
1101:                     *
1102:                     *
1103:                     * Side Effects:    None
1104:                     *
1105:                     * Overview:        The function suspends the DMA controller.
1106:                     *
1107:                     * Note:            After the execution of this function the DMA operation is supposed to be suspended.
1108:                     *                  I.e. the function has to wait for the suspension to take place!
1109:                     *
1110:                     * Example:         int susp=DmaSuspend();
1111:                     ********************************************************************/
1112:                        extern __inline__ int __attribute__((always_inline)) DmaSuspend(void)
1113:                    {
1114:                        int suspSt;
1115:                        if(!(suspSt=DMACONbits.SUSPEND))
9D000D84  3C02BF88   LUI V0, -16504
9D000D88  8C423000   LW V0, 12288(V0)
9D000D8C  7C420300   EXT V0, V0, 12, 1
9D000D90  304200FF   ANDI V0, V0, 255
9D000D94  AFC20038   SW V0, 56(S8)
9D000D98  8FC20038   LW V0, 56(S8)
9D000D9C  14400009   BNE V0, ZERO, 0x9D000DC4
9D000DA0  00000000   NOP
9D000E58  3C02BF88   LUI V0, -16504
9D000E5C  8C423000   LW V0, 12288(V0)
9D000E60  7C420300   EXT V0, V0, 12, 1
9D000E64  304200FF   ANDI V0, V0, 255
9D000E68  AFC20044   SW V0, 68(S8)
9D000E6C  8FC20044   LW V0, 68(S8)
9D000E70  1440000E   BNE V0, ZERO, 0x9D000EAC
9D000E74  00000000   NOP
1116:                        {
1117:                            DMACONSET=_DMACON_SUSPEND_MASK;     // suspend
9D000DA4  3C02BF88   LUI V0, -16504
9D000DA8  24031000   ADDIU V1, ZERO, 4096
9D000DAC  AC433008   SW V1, 12296(V0)
9D000E78  3C02BF88   LUI V0, -16504
9D000E7C  24031000   ADDIU V1, ZERO, 4096
9D000E80  AC433008   SW V1, 12296(V0)
1118:                            while((DMACONbits.DMABUSY));    // wait to be actually suspended
9D000DB0  3C02BF88   LUI V0, -16504
9D000DB4  8C423000   LW V0, 12288(V0)
9D000DB8  30420800   ANDI V0, V0, 2048
9D000DBC  1440FFFC   BNE V0, ZERO, 0x9D000DB0
9D000DC0  00000000   NOP
9D000E84  3C02BF88   LUI V0, -16504
9D000E88  8C423000   LW V0, 12288(V0)
9D000E8C  30420800   ANDI V0, V0, 2048
9D000E90  1440FFFC   BNE V0, ZERO, 0x9D000E84
9D000E94  00000000   NOP
9D000E98  0B4003AB   J 0x9D000EAC
9D000E9C  00000000   NOP
1119:                        }
1120:                        return suspSt;
9D000DC4  8FC20038   LW V0, 56(S8)
1121:                    }
1122:                
1123:                
1124:                
1125:                    /*********************************************************************
1126:                     * Function:        void DmaResume(int susp)
1127:                     *
1128:                     * PreCondition:    None
1129:                     *
1130:                     * Input:       the desired DMA suspended state.
1131:                     *
1132:                     * Output:          None
1133:                     *
1134:                     * Side Effects:    None
1135:                     *
1136:                     * Overview:        The function restores the DMA controller activity to the old suspended mode.
1137:                     *
1138:                     * Note:            None.
1139:                     *
1140:                     * Example:         int isSusp=DmaSuspend(); {....}; DmaResume(isSusp);
1141:                     ********************************************************************/
1142:                        extern __inline__ void __attribute__((always_inline)) DmaResume(int susp)
1143:                    {
1144:                        if(susp)
9D000E4C  8FC20040   LW V0, 64(S8)
9D000E50  10400013   BEQ V0, ZERO, 0x9D000EA0
9D000E54  00000000   NOP
1145:                        {
1146:                            DmaSuspend();
1147:                        }
1148:                        else
1149:                        {
1150:                            DMACONCLR=_DMACON_SUSPEND_MASK;     // resume DMA activity
9D000EA0  3C02BF88   LUI V0, -16504
9D000EA4  24031000   ADDIU V1, ZERO, 4096
9D000EA8  AC433004   SW V1, 12292(V0)
1151:                        }
1152:                    }
1153:                
1154:                    /*********************************************************************
1155:                     * Function:        void DmaGetStatus(DmaStatus* pStat)
1156:                     *
1157:                     * PreCondition:    pStat   - valid pointer
1158:                     *
1159:                     * Input:           pStat   - pointer to a DmaStatus structure to store the current DMA controller
1160:                     *                          status, carrying the following info:
1161:                     *                              - chn:  the last active DMA channel
1162:                     *                              - rdOp: the last DMA operation, read/write
1163:                     *                              - lastAddress: the most recent DMA address
1164:                     *
1165:                     * Output:          None
1166:                     *
1167:                     * Side Effects:    None
1168:                     *
1169:                     * Overview:        The function updates the info for the current DMA controller status.
1170:                     *                  It updates the last DMA: operation, channel used and address.
1171:                     *
1172:                     * Note:            None.
1173:                     *
1174:                     * Example:         DmaStatus stat; DmaGetStatus(&stat);
1175:                     ********************************************************************/
1176:                     void           DmaGetStatus(DmaStatus* pStat);
1177:                
1178:                    /*********************************************************************
1179:                     * Function:        void DmaSetGlobalFlags(DmaGlblFlags gFlags)
1180:                     *
1181:                     * PreCondition:    None
1182:                     *
1183:                     * Input:           gFlags - flags to be set, having the following fields:
1184:                     *          - DMA_GFLG_SUSPEND: DMA controller operation suspend
1185:                     *          - DMA_GFLG_ON: DMA controller enabled/desabled
1186:                     *          - DMA_GFLG_ALL_FLAGS: all flags
1187:                     *
1188:                     * Output:          None
1189:                     *
1190:                     * Side Effects:    None
1191:                     *
1192:                     * Overview:        The function affects the global behavior of the DMA controller.
1193:                     *                  It sets the specified flags. Any flag that is set in the gFlags will be
1194:                     *                  enabled, the other flags won't be touched.
1195:                     *
1196:                     * Note:            None.
1197:                     *
1198:                     * Example:         DmaSetGlobalFlags(DMA_GFLG_ON);
1199:                     ********************************************************************/
1200:                        extern __inline__ void __attribute__((always_inline)) DmaSetGlobalFlags(DmaGlblFlags gFlags)
1201:                    {
1202:                        DMACONSET=gFlags;
1203:                    }
1204:                
1205:                    /*********************************************************************
1206:                     * Function:        void DmaClrGlobalFlags(DmaGlblFlags gFlags)
1207:                     *
1208:                     * PreCondition:    None
1209:                     *
1210:                     * Input:           gFlags - flags to be cleared, having the following fields:
1211:                     *                               - DMA_GFLG_SUSPEND: DMA controller operation suspend
1212:                     *                               - DMA_GFLG_ON: DMA controller enabled/desabled
1213:                     *                               - DMA_GFLG_ALL_FLAGS: all flags
1214:                     *
1215:                     * Output:          None
1216:                     *
1217:                     * Side Effects:    None
1218:                     *
1219:                     * Overview:        The function affects the global behavior of the DMA controller.
1220:                     *                  It clears the specified flags. Any flag that is set in the gFlags will be
1221:                     *                  cleared, the other flags won't be touched.
1222:                     *
1223:                     * Note:            None.
1224:                     *
1225:                     * Example:         DmaClrGlobalFlags(DMA_GFLG_SUSPEND);
1226:                     ********************************************************************/
1227:                        extern __inline__ void __attribute__((always_inline)) DmaClrGlobalFlags(DmaGlblFlags gFlags)
1228:                    {
1229:                        DMACONCLR=gFlags;
1230:                    }
1231:                
1232:                
1233:                    /*********************************************************************
1234:                     * Function:        void DmaWriteGlobalFlags(DmaGlblFlags gFlags)
1235:                     *
1236:                     * PreCondition:    None
1237:                     *
1238:                     * Input:           gFlags - flags to be set, having the following fields:
1239:                     *                                 - DMA_GFLG_SUSPEND: DMA controller operation suspend
1240:                     *                                 - DMA_GFLG_ON: DMA controller enabled/desabled
1241:                     *                                 - DMA_GFLG_ALL_FLAGS: all flags
1242:                     *
1243:                     * Output:          None
1244:                     *
1245:                     * Side Effects:    None
1246:                     *
1247:                     * Overview:        The function affects the global behavior of the DMA controller.
1248:                     *                  It forces the flags to have the specified gFlags value.
1249:                     *
1250:                     * Note:            None.
1251:                     *
1252:                     * Example:         DmaWriteGlobalFlags(DMA_GFLG_ALL_FLAGS);
1253:                     ********************************************************************/
1254:                        extern __inline__ void __attribute__((always_inline)) DmaWriteGlobalFlags(DmaGlblFlags gFlags)
1255:                    {
1256:                        DMACON=gFlags;
1257:                    }
1258:                
1259:                    /*********************************************************************
1260:                     * Function:        DmaGlblFlags DmaGetGlobalFlags(void)
1261:                     *
1262:                     * PreCondition:    None
1263:                     *
1264:                     * Input:           None
1265:                     *
1266:                     * Output:          The current DMA controller flags settings.
1267:                     *                              - DMA_GFLG_SUSPEND: DMA controller operation suspend
1268:                     *                              - DMA_GFLG_ON: DMA controller enabled/desabled
1269:                     *
1270:                     * Side Effects:    None
1271:                     *
1272:                     * Overview:        The function returns the global flags of the DMA controller.
1273:                     *
1274:                     * Note:            None.
1275:                     *
1276:                     * Example:         DmaGlblFlags dmaFlags=DmaGetGlobalFlags();
1277:                     ********************************************************************/
1278:                        extern __inline__ DmaGlblFlags __attribute__((always_inline)) DmaGetGlobalFlags(void)
1279:                    {
1280:                        return (DmaGlblFlags)DMACON;
1281:                    }
1282:                
1283:                
1284:                    /*********************************************************************
1285:                     * Function:        int DmaGetMaxTxferSize(void)
1286:                     *
1287:                     * PreCondition:    None
1288:                     *
1289:                     * Input:           None
1290:                     *
1291:                     * Output:          The maximum transfer capacity for a DMA channel, in bytes.
1292:                     *
1293:                     * Side Effects:    None
1294:                     *
1295:                     * Overview:        The function returns the maximum number of bytes that can be transferred by a DMA channel.
1296:                     *
1297:                     * Note:            Revision dependant.
1298:                     *
1299:                     * Example:         int dmaMaxSz=DmaGetMaxTxferSize();
1300:                     ********************************************************************/
1301:                    extern __inline__ int __attribute__((always_inline)) DmaGetMaxTxferSize(void)
1302:                    {
1303:                        return 65536;
1304:                    }
1305:                
1306:                    // Direct Channel control functions
1307:                
1308:                    typedef enum
1309:                    {
1310:                        DMA_CONFIG_DEFAULT = 0,                             // DMA default operation
1311:                        DMA_CONFIG_AUTO = _DCH0CON_CHAEN_MASK,              // DMA channel is auto enabled
1312:                        DMA_CONFIG_CHAIN_LOW  = (_DCH0CON_CHCHN_MASK|_DCH0CON_CHCHNS_MASK), // DMA channel is chained to lower channel
1313:                        DMA_CONFIG_CHAIN_HI  = (_DCH0CON_CHCHN_MASK),       // DMA channel is chained to higher channel
1314:                        DMA_CONFIG_DET_EN = _DCH0CON_CHAED_MASK,            // events detection enabled while channel off
1315:                        DMA_CONFIG_ENABLE = _DCH0CON_CHEN_MASK,             // DMA channel is enabled after open
1316:                        DMA_CONFIG_MATCH    = 0x80000000,                   // DMA channel stops on match
1317:                    }DmaConfigFlags;    // flags for the channel configuration
1318:                
1319:                
1320:                
1321:                    /*********************************************************************
1322:                     * Function:        void DmaChnConfigure(DmaChannel chn, DmaChannelPri chPri, DmaConfigFlags cFlags)
1323:                     *
1324:                     * PreCondition:    chPri  - valid channel priority, 0-3
1325:                     *
1326:                     * Input:           chn    - channel to be configured in the DMA controller
1327:                     *                  chPri  - the priority given to the channel, 0-3
1328:                     *                  cFlags - orred flags specifying the configuration:
1329:                     *                           DMA_CONFIG_DEFAULT: DMA default operation mode
1330:                     *                           DMA_CONFIG_AUTO:   DMA channel is auto enabled
1331:                     *                           DMA_CONFIG_CHAIN_LOW: DMA channel is chained to lower channel
1332:                     *                           DMA_CONFIG_CHAIN_HI: DMA channel is chained to higher channel
1333:                     *                           DMA_CONFIG_DET_EN: events detection enabled while channel off
1334:                     *                           DMA_CONFIG_ENABLE: DMA channel is enabled when opened
1335:                     *                           DMA_CONFIG_MATCH:  DMA channel stops on match
1336:                     *
1337:                     *
1338:                     *
1339:                     * Output:          None
1340:                     *
1341:                     * Side Effects:    None
1342:                     *
1343:                     * Overview:        The function configures the selected DMA channel using the supplied user flags and priority.
1344:                     *
1345:                     * Note:            - The channel is NOT turned off. It should be turned off before calling this function.
1346:                     *                  The channel is just configured.
1347:                     *                  - After calling this function, the channel should be enabled using DmaChnEnable(chn) call
1348:                     *                  if DMA_CONFIG_ENABLE flag was not specified.
1349:                     *                  - The function does not touch the interrupt flags, interrupt enables, etc.
1350:                     *                  The interrupt flags should have been previously cleared and interrupts disabled before calling this function.
1351:                     *                  - The start and abort Irqs, the channel event enable flags are not touched/cleared by this function.
1352:                     *                  User has to call event channel functions to clear/enable the event flags if needed.
1353:                     *
1354:                     * Example:         DmaChnDisable(DMA_CHANNEL2); DmaChnConfigure(DMA_CHANNEL2, DMA_CHN_PRI2, DMA_CONFIG_AUTO|DMA_CONFIG_MATCH|DMA_CONFIG_ENABLE);
1355:                     ********************************************************************/
1356:                    void            DmaChnConfigure(DmaChannel chn, DmaChannelPri chPri, DmaConfigFlags cFlags);
1357:                
1358:                
1359:                    /*********************************************************************
1360:                     * Function:        int DmaChnGetSrcPnt(DmaChannel chn)
1361:                     *
1362:                     * PreCondition:    chn - valid DMA channel
1363:                     *
1364:                     * Input:           chn     - DMA channel number
1365:                     *
1366:                     * Output:          Current channel source pointer.
1367:                     *
1368:                     * Side Effects:    None
1369:                     *
1370:                     * Overview:        The function retrieves the current source pointer for the selected DMA channel.
1371:                     *                  It is the current offset, 0 to DmaGetMaxTxferSize()-1, in the source transfer buffer.
1372:                     *
1373:                     * Note:            None
1374:                     *
1375:                     * Example:         int srcPnt=DmaChnGetSrcPnt(DMA_CHANNEL3);
1376:                     ********************************************************************/
1377:                     int            DmaChnGetSrcPnt(DmaChannel chn);
1378:                
1379:                    /*********************************************************************
1380:                     * Function:        int DmaChnGetDstPnt(DmaChannel chn)
1381:                     *
1382:                     * PreCondition:    chn - valid DMA channel
1383:                     *
1384:                     * Input:           chn     - DMA channel number
1385:                     *
1386:                     * Output:          Current channel destination pointer.
1387:                     *
1388:                     * Side Effects:    None
1389:                     *
1390:                     * Overview:        The function retrieves the current destination pointer for the selected DMA channel.
1391:                     *                  It is the current offset, 0 to DmaGetMaxTxferSize()-1, in the destination transfer buffer.
1392:                     *
1393:                     * Note:            None
1394:                     *
1395:                     * Example:         int dstPnt=DmaChnGetDstPnt(DMA_CHANNEL3);
1396:                     ********************************************************************/
1397:                     int            DmaChnGetDstPnt(DmaChannel chn);
1398:                
1399:                    /*********************************************************************
1400:                     * Function:        int DmaChnGetCellPnt(DmaChannel chn)
1401:                     *
1402:                     * PreCondition:    chn - valid DMA channel
1403:                     *
1404:                     * Input:           chn     - DMA channel number
1405:                     *
1406:                     * Output:          Current channel transfer pointer.
1407:                     *
1408:                     * Side Effects:    None
1409:                     *
1410:                     * Overview:        The function retrieves the current transfer progress pointer for the selected DMA channel.
1411:                     *                  It ranges 0 to DmaGetMaxTxferSize()-1.
1412:                     *
1413:                     * Note:            None
1414:                     *
1415:                     * Example:         int cellPnt=DmaChnGetCellPnt(DMA_CHANNEL3);
1416:                     ********************************************************************/
1417:                     int            DmaChnGetCellPnt(DmaChannel chn);
1418:                
1419:                
1420:                
1421:                    /*********************************************************************
1422:                     * Function:        void DmaChnSetEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1423:                     *
1424:                     * PreCondition:    chn - valid DMA channel
1425:                     *
1426:                     * Input:           chn         - DMA channel number
1427:                     *                  dmaEvCtrl   -   either a DmaEvCtrl structure field, carrying the following info:
1428:                     *                                      - AIRQEN: enable/disable the abort IRQ action
1429:                     *                                      - SIRQEN: enable/disable the start IRQ action
1430:                     *                                      - PATEN: enable/disable the pattern match and abort
1431:                     *                                  or any of the DmaEvCtrlFlags:
1432:                     *                                      DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN
1433:                     *
1434:                     *
1435:                     * Output:          None
1436:                     *
1437:                     * Side Effects:    None
1438:                     *
1439:                     * Overview:        The function sets the events that start and abort the transfer
1440:                     *                  for the selected DMA channel.
1441:                     *                  Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
1442:                     *                  enabled for the selected channel, the other channel event flags won't be touched.
1443:                     *
1444:                     * Note:            None.
1445:                     *
1446:                     * Example:         either:
1447:                     *                      DmaChnSetEventControlFlags(DMA_CHANNEL3, DMA_EV_MATCH_EN|DMA_EV_START_IRQ_EN;
1448:                     *                  or:
1449:                     *                      DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.PATEN=1; evCtrl.SIRQEN=1;
1450:                     *                      DmaChnSetEventControlFlags(DMA_CHANNEL3, evCtrl.w);
1451:                     *
1452:                     ********************************************************************/
1453:                     void           DmaChnSetEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl);
1454:                
1455:                
1456:                    /*********************************************************************
1457:                     * Function:        void DmaChnClrEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1458:                     *
1459:                     * PreCondition:    chn - valid DMA channel
1460:                     *
1461:                     * Input:           chn         - DMA channel number
1462:                     *                  dmaEvCtrl   -   either a DmaEvCtrl structure field, carrying the following info:
1463:                     *                                      - AIRQEN: enable/disable the abort IRQ action
1464:                     *                                      - SIRQEN: enable/disable the start IRQ action
1465:                     *                                      - PATEN: enable/disable the pattern match and abort
1466:                     *                                  or any of the DmaEvCtrlFlags:
1467:                     *                                      DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN
1468:                     *
1469:                     *
1470:                     * Output:          None
1471:                     *
1472:                     * Side Effects:    None
1473:                     *
1474:                     * Overview:        The function clears the events that start and abort the transfer
1475:                     *                  for the selected DMA channel.
1476:                     *                  Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
1477:                     *                  disabled for the selected channel, the other channel event flags won't be touched.
1478:                     *
1479:                     * Note:            None.
1480:                     *
1481:                     * Example:         either:
1482:                     *                      DmaChnClrEventControlFlags(DMA_CHANNEL3, DMA_EV_MATCH_EN|DMA_EV_START_IRQ_EN);
1483:                     *                  or:
1484:                     *                      DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.PATEN=1; evCtrl.AIRQEN=1;
1485:                     *                      DmaChnClrEventControlFlags(DMA_CHANNEL3, evCtrl.w);
1486:                     *
1487:                     ********************************************************************/
1488:                     void           DmaChnClrEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl);
1489:                
1490:                
1491:                
1492:                    /*********************************************************************
1493:                     * Function:        void DmaChnWriteEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1494:                     *
1495:                     * PreCondition:    chn - valid DMA channel
1496:                     *
1497:                     * Input:           chn         - DMA channel number
1498:                     *                  dmaEvCtrl   -   either a DmaEvCtrl structure field, carrying the following info:
1499:                     *                                      - AIRQEN: enable/disable the abort IRQ action
1500:                     *                                      - SIRQEN: enable/disable the start IRQ action
1501:                     *                                      - PATEN: enable/disable the pattern match and abort
1502:                     *                                      - CHSIRQ: IRQ number to start the DMA channel transfer
1503:                     *                                      - CHAIRQ: IRQ number to abort the DMA channel transfer
1504:                     *                                  or any of the DmaEvCtrlFlags:
1505:                     *                                      DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN|DMA_EV_START_IRQ(irq)|DMA_EV_ABORT_IRQ(irq)
1506:                     *
1507:                     *
1508:                     * Output:          None
1509:                     *
1510:                     * Side Effects:    None
1511:                     *
1512:                     * Overview:        The function writes the events that start and abort the transfer
1513:                     *                  for the selected DMA channel.
1514:                     *
1515:                     * Note:            None.
1516:                     *
1517:                     * Example:         either:
1518:                     *                      DmaChnWriteEventControlFlags(DMA_CHANNEL3, DMA_EV_MATCH_EN|DMA_EV_START_IRQ(_UART2_RX_IRQ));
1519:                     *                  or:
1520:                     *                      DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.AIRQEN=1; evCtrl.PATEN=1; evCtrl.CHSIRQ=_UART2_RX_IRQ;
1521:                     *                      DmaChnWriteEventControlFlags(DMA_CHANNEL3, evCtrl.w);
1522:                     *
1523:                     ********************************************************************/
1524:                     void           DmaChnWriteEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl);
1525:                
1526:                
1527:                
1528:                    /*********************************************************************
1529:                     * Function:        void DmaChnSetEventControl(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1530:                     *
1531:                     * PreCondition:    chn - valid DMA channel
1532:                     *
1533:                     * Input:           chn         - DMA channel number
1534:                     *                  dmaEvCtrl   -   either a DmaEvCtrl structure field, carrying the following info:
1535:                     *                                      - AIRQEN: enable/disable the abort IRQ action
1536:                     *                                      - SIRQEN: enable/disable the start IRQ action
1537:                     *                                      - PATEN: enable/disable the pattern match and abort
1538:                     *                                      - CHSIRQ: IRQ number to start the DMA channel transfer
1539:                     *                                      - CHAIRQ: IRQ number to abort the DMA channel transfer
1540:                     *                                  or any of the DmaEvCtrlFlags:
1541:                     *                                      DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN|DMA_EV_START_IRQ(irq)|DMA_EV_ABORT_IRQ(irq)
1542:                     *
1543:                     *
1544:                     * Output:          None
1545:                     *
1546:                     * Side Effects:    None
1547:                     *
1548:                     * Overview:        The function sets the events that start and abort the transfer
1549:                     *                  for the selected DMA channel.
1550:                     *                  Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
1551:                     *                  enabled for the selected channel, the other channel event flags won't be touched.
1552:                     *
1553:                     * Note:           A shorter name for DmaChnWriteEventControlFlags();
1554:                     *
1555:                     * Example:         either:
1556:                     *                      DmaChnSetEventControl(DMA_CHANNEL3, DMA_EV_MATCH_EN|DMA_EV_START_IRQ(_UART2_RX_IRQ));
1557:                     *                  or:
1558:                     *                      DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.AIRQEN=1; evCtrl.PATEN=1; evCtrl.CHSIRQ=_UART2_RX_IRQ;
1559:                     *                      DmaChnSetEventControl(DMA_CHANNEL3, evCtrl.w);
1560:                     *
1561:                     ********************************************************************/
1562:                    #define         DmaChnSetEventControl(chn, dmaEvCtrl)   DmaChnWriteEventControlFlags(chn, dmaEvCtrl)
1563:                
1564:                
1565:                    /*********************************************************************
1566:                     * Function:        DmaEvCtrlFlags DmaChnGetEventControl(DmaChannel chn)
1567:                     *
1568:                     * PreCondition:    chn - valid DMA channel
1569:                     *
1570:                     * Input:           chn     - DMA channel number
1571:                     *
1572:                     * Output:          -   either a DmaEvCtrl structure field, carrying the following info:
1573:                     *                          - AIRQEN: enable/disable the abort IRQ action
1574:                     *                          - SIRQEN: enable/disable the start IRQ action
1575:                     *                          - PATEN: enable/disable the pattern match and abort
1576:                     *                          - CHSIRQ: IRQ number to start the DMA channel transfer
1577:                     *                          - CHAIRQ: IRQ number to abort the DMA channel transfer
1578:                     *                      or any of the DmaEvCtrlFlags:
1579:                     *                          DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN|DMA_EV_START_IRQ(irq)|DMA_EV_ABORT_IRQ(irq)
1580:                     *
1581:                     *
1582:                     * Side Effects:    None
1583:                     *
1584:                     * Overview:        The function retrieves the events that start and abort the transfer
1585:                     *                  for the selected DMA channel.
1586:                     *
1587:                     * Note:            None.
1588:                     *
1589:                     * Example:         either:
1590:                     *                      DmaEvCtrlFlags evCtrlW=DmaChnGetEventControl(DMA_CHANNEL3); if(evCtrlW&DMA_EV_MATCH_EN) {...}
1591:                     *                  or:
1592:                     *                      DmaEvCtrl evCtrl; evCtrl.w=DmaChnGetEventControl(DMA_CHANNEL3); if(evCtrl.PATEN){...}
1593:                     *
1594:                     ********************************************************************/
1595:                     DmaEvCtrlFlags DmaChnGetEventControl(DmaChannel chn);
1596:                
1597:                
1598:                    /*********************************************************************
1599:                     * Function:        void DmaChnSetControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1600:                     *
1601:                     * PreCondition:    chn - valid DMA channel
1602:                     *
1603:                     * Input:           chn         - DMA channel number
1604:                     *                  dmaChnCtrl  -   either a DmaChnCtrl structure field, carrying the following info:
1605:                     *                                      - autoEn: enable/disable the automatic mode
1606:                     *                                      - chainEn: enable/disable channel chaining
1607:                     *                                      - detectEn: enable/disable events detection when channel disabled
1608:                     *                                      - chEn: enable/disable channel functionality
1609:                     *                                      - chainDir: chain direction: chain to lower(1)/higher(0),pri channel
1610:                     *                                  or any of the DmaChnCtrlFlags flags:
1611:                     *                                      DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1612:                     *
1613:                     * Output:          None
1614:                     *
1615:                     * Side Effects:    None
1616:                     *
1617:                     * Overview:        The function sets the selected DMA channel control flags:
1618:                     *                  the chaining or auto mode, and events detection.
1619:                     *                  Multiple flags can be orr-ed together. Any flag that is set in the dmaChnCtrl will be
1620:                     *                  set for the selected channel, the other channel control flags won't be touched.
1621:                     *
1622:                     * Note:            None.
1623:                     *
1624:                     * Example:         either:
1625:                     *                      DmaChnSetControlFlags(DMA_CHANNEL3, DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1626:                     *                  or:
1627:                     *                      DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.autoEn=1; chCtrl.chainEn=1;
1628:                     *                      DmaChnSetControlFlags(DMA_CHANNEL3, chCtrl.w);
1629:                     *
1630:                     ********************************************************************/
1631:                     void           DmaChnSetControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl);
1632:                
1633:                    /*********************************************************************
1634:                     * Function:        void DmaChnClrControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1635:                     *
1636:                     * PreCondition:    chn - valid DMA channel
1637:                     *
1638:                     * Input:           chn         - DMA channel number
1639:                     *                  dmaChnCtrl  -   either a DmaChnCtrl structure field, carrying the following info:
1640:                     *                                      - autoEn: enable/disable the automatic mode
1641:                     *                                      - chainEn: enable/disable channel chaining
1642:                     *                                      - detectEn: enable/disable events detection when channel disabled
1643:                     *                                      - chEn: enable/disable channel functionality
1644:                     *                                      - chainDir: chain direction: chain to lower(1)/higher(0),pri channel
1645:                     *                                  or any of the DmaChnCtrlFlags flags:
1646:                     *                                      DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1647:                     *
1648:                     * Output:          None
1649:                     *
1650:                     * Side Effects:    None
1651:                     *
1652:                     * Overview:        The function clears the selected DMA channel control flags:
1653:                     *                  the chaining or auto mode and events detection.
1654:                     *                  Multiple flags can be orr-ed together. Any flag that is set in the dmaChnCtrl will be
1655:                     *                  cleared for the selected channel, the other channel control flags won't be touched.
1656:                     *
1657:                     * Note:            None.
1658:                     *
1659:                     * Example:         either:
1660:                     *                      DmaChnClrControlFlags(DMA_CHANNEL3, DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1661:                     *                  or:
1662:                     *                      DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.autoEn=1; chCtrl.chainEn=1;
1663:                     *                      DmaChnClrControlFlags(DMA_CHANNEL3, chCtrl.w);
1664:                     *
1665:                     ********************************************************************/
1666:                     void           DmaChnClrControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl);
1667:                
1668:                    /*********************************************************************
1669:                     * Function:        void DmaChnWriteControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1670:                     *
1671:                     * PreCondition:    chn - valid DMA channel
1672:                     *
1673:                     * Input:           chn         - DMA channel number
1674:                     *                  dmaChnCtrl  -   either a DmaChnCtrl structure field, carrying the following info:
1675:                     *                                      - chPri: channel priority 0-3
1676:                     *                                      - autoEn: enable/disable the automatic mode
1677:                     *                                      - chainEn: enable/disable channel chaining
1678:                     *                                      - detectEn: enable/disable events detection when channel disabled
1679:                     *                                      - chEn: enable/disable channel functionality
1680:                     *                                      - chainDir: chain direction: chain to lower(1)/higher(0),pri channel
1681:                     *                                  or any of the DmaChnCtrlFlags flags:
1682:                     *                                      DMA_CTL_PRI(pri)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1683:                     *
1684:                     * Output:          None
1685:                     *
1686:                     * Side Effects:    None
1687:                     *
1688:                     * Overview:        The function enables/disables the selected DMA channel and also sets
1689:                     *                  the channel priority, chaining mode or auto and events detection.
1690:                     *
1691:                     * Note:            None.
1692:                     *
1693:                     * Example:         either:
1694:                     *                      DmaChnWriteControlFlags(DMA_CHANNEL3, DMA_CTL_PRI(DMA_CHN_PRI2)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1695:                     *                  or:
1696:                     *                      DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.chPri=DMA_CHN_PRI2; chCtrl.autoEn=1; chCtrl.chainEn=1;
1697:                     *                      DmaChnWriteControlFlags(DMA_CHANNEL3, chCtrl.w);
1698:                     *
1699:                     ********************************************************************/
1700:                     void           DmaChnWriteControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl);
1701:                
1702:                    /*********************************************************************
1703:                     * Function:        void DmaChnSetControl(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1704:                     *
1705:                     * PreCondition:    chn - valid DMA channel
1706:                     *
1707:                     * Input:       chn     - DMA channel number
1708:                     *                  dmaChnCtrl  -   either a DmaChnCtrl structure field, carrying the following info:
1709:                     *                      - chPri: channel priority 0-3
1710:                     *                      - autoEn: enable/disable the automatic mode
1711:                     *                      - chainEn: enable/disable channel chaining
1712:                     *                      - detectEn: enable/disable events detection when channel disabled
1713:                     *                      - chEn: enable/disable channel functionality
1714:                     *                      - chainDir: chain direction: chain to lower(1)/higher(0),pri channel
1715:                     *                  or any of the DmaChnCtrlFlags flags:
1716:                     *                      DMA_CTL_PRI(pri)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1717:                     *
1718:                     * Output:          None
1719:                     *
1720:                     * Side Effects:    None
1721:                     *
1722:                     * Overview:        The function enables/disables the selected DMA channel and also sets
1723:                     *                  the channel priority, chaining mode or auto and events detection.
1724:                     *
1725:                     * Note:            Another name ( backward compatible) for DmaChnWriteControlFlags().
1726:                     *
1727:                     * Example:         either:
1728:                     *                      DmaChnSetControl(DMA_CHANNEL3, DMA_CTL_PRI(DMA_CHN_PRI2)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1729:                     *                  or:
1730:                     *                      DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.chPri=DMA_CHN_PRI2; chCtrl.autoEn=1; chCtrl.chainEn=1;
1731:                     *          DmaChnSetControl(DMA_CHANNEL3, chCtrl.w);
1732:                     *
1733:                     ********************************************************************/
1734:                    #define     DmaChnSetControl(chn, dmaChnCtrl)   DmaChnWriteControlFlags(chn, dmaChnCtrl)
1735:                
1736:                    /*********************************************************************
1737:                     * Function:        DmaChnCtrlFlags DmaChnGetControlFlags(DmaChannel chn)
1738:                     *
1739:                     * PreCondition:    chn - valid DMA channel
1740:                     *
1741:                     * Input:           chn         - DMA channel number
1742:                     *
1743:                     * Output:          - either a DmaChnCtrl structure field, carrying the following info:
1744:                     *                          - chPri: channel priority 0-3
1745:                     *                          - autoEn: enable/disable the automatic mode
1746:                     *                          - chainEn: enable/disable channel chaining
1747:                     *                          - detectEn: enable/disable events detection when channel disabled
1748:                     *                          - chEn: enable/disable channel functionality
1749:                     *                          - chainDir: chain direction: chain to lower(1)/higher(0),pri channel
1750:                     *                      or any of the DmaChnCtrlFlags flags:
1751:                     *                          DMA_CTL_PRI(pri)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1752:                     *
1753:                     * Side Effects:    None
1754:                     *
1755:                     * Overview:        The function retrieves the current control settings for the selected DMA channel,
1756:                     *                  including the channel enable/disable status, the channel priority,
1757:                     *                  chaining mode, auto mode and events detection.
1758:                     *
1759:                     * Note:            None.
1760:                     *
1761:                     * Example:         either:
1762:                     *                      DmaChnCtrlFlags ctrl=DmaChnGetControlFlags(DMA_CHANNEL3); if(ctrl&DMA_CTL_AUTO_EN) {...}
1763:                     *                  or:
1764:                     *                      DmaChnCtrl chnCtrl; chnCtrl.w=DmaChnGetControlFlags(DMA_CHANNEL3); if(chnCtrl.autoEn) {...}
1765:                     *
1766:                     ********************************************************************/
1767:                     DmaChnCtrlFlags    DmaChnGetControlFlags(DmaChannel chn);
1768:                
1769:                
1770:                    /*********************************************************************
1771:                     * Function:        int DmaChnGetEvDetect(DmaChannel chn)
1772:                     *
1773:                     * PreCondition:    chn - valid DMA channel
1774:                     *
1775:                     * Input:           chn     - DMA channel number
1776:                     *
1777:                     * Output:          TRUE if an DMA event was detected, FALSE otherwise.
1778:                     *
1779:                     * Side Effects:    None
1780:                     *
1781:                     * Overview:        The function returns the current event detection for the selected DMA channel.
1782:                     *
1783:                     * Note:            None.
1784:                     *
1785:                     * Example:         int evDetect=DmaChnGetEvDetect(DMA_CHANNEL3);
1786:                     *
1787:                     ********************************************************************/
1788:                     int            DmaChnGetEvDetect(DmaChannel chn);
1789:                
1790:                    /*********************************************************************
1791:                     * Function:        void DmaChnGetTxfer(DmaChannel chn, DmaTxferCtrl* pTxCtrl, int mapToK0)
1792:                     *
1793:                     * PreCondition:    chn     - valid DMA channel
1794:                     *                  pTxCtrl - valid pointer
1795:                     *
1796:                     * Input:           chn         - DMA channel number
1797:                     *                  pTxCtrl     - pointer to a DmaTxferCtrl that will carry the following info:
1798:                     *                              - vSrcAdd: source of the DMA transfer
1799:                     *                              - vDstAdd: destination of the DMA transfer
1800:                     *                              - srcSize: source buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped arround
1801:                     *                              - dstSize: destination buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped around
1802:                     *                              - cellSize: cell transfer size, 1 to DmaGetMaxTxferSize() bytes.
1803:                     *                  mapToK0     - if TRUE, a Kernel address is mapped to KSeg0, else KSeg1.
1804:                     *
1805:                     * Output:          None
1806:                     *
1807:                     * Side Effects:    None
1808:                     *
1809:                     * Overview:        The function retrieves the transfer characteristics for a DMA channel transfer:
1810:                     *                  the source and the destination addresses.
1811:                     *                  It also retrieves the source and destination lengths
1812:                     *                  and the number of bytes transferred per event.
1813:                     *
1814:                     * Note:            None
1815:                     *
1816:                     * Example:         DmaTxferCtrl txCtl; DmaChnGetTxfer(DMA_CHANNEL3, &txCtl, FALSE);
1817:                     ********************************************************************/
1818:                     void           DmaChnGetTxfer(DmaChannel chn, DmaTxferCtrl* pTxCtrl, int mapToK0);
1819:                
1820:                    // Low level checksum functions
1821:                
1822:                    /*********************************************************************
1823:                     * Function:        void DmaSfmEnable(int enable)
1824:                     *
1825:                     * PreCondition:    None
1826:                     *
1827:                     * Input:           enable _ boolean to enable/disable the SFM functionality
1828:                     *
1829:                     * Output:          None
1830:                     *
1831:                     * Side Effects:    None
1832:                     *
1833:                     * Overview:        The function enables/diables the checksum module functionality.
1834:                     *                  When enabled the attached DMA channel transfers are routed to the SFM module.
1835:                     *
1836:                     * Note:            The SFM module should be properly configured before enabled.
1837:                     *
1838:                     * Example:         DmaSfmEnable(1);
1839:                     ********************************************************************/
1840:                    extern __inline__ void __attribute__((always_inline)) DmaSfmEnable(int enable)
1841:                    {
1842:                        if(enable)
1843:                        {
1844:                            DCRCCONSET=_DCRCCON_CRCEN_MASK;
1845:                        }
1846:                        else
1847:                        {
1848:                            DCRCCONCLR=_DCRCCON_CRCEN_MASK;
1849:                        }
1850:                    }
1851:                    #define DmaCrcEnable    DmaSfmEnable        // PIC32_3xx backward compatibility
1852:                
1853:                
1854:                    /*********************************************************************
1855:                     * Function:        int DmaSfmGetEnable(void)
1856:                     *
1857:                     * PreCondition:    None
1858:                     *
1859:                     * Input:           None
1860:                     *
1861:                     * Output:          TRUE, if the SFM module is enabled
1862:                     *          FALSE otherwise
1863:                     *
1864:                     * Side Effects:    None
1865:                     *
1866:                     * Overview:        The function returns the SFM module enabling status.
1867:                     *
1868:                     * Note:            None
1869:                     *
1870:                     * Example:     int isSfmEnabled=DmaSfmGetEnable();
1871:                     ********************************************************************/
1872:                    extern __inline__ int __attribute__((always_inline)) DmaSfmGetEnable(void)
1873:                    {
1874:                        return DCRCCONbits.CRCEN!=0;
1875:                    }
1876:                    #define     DmaCrcGetEnable     DmaSfmGetEnable     // PIC32_3xx backward compatibility
1877:                
1878:                
1879:                    /*********************************************************************
1880:                     * Function:        void DmaSfmAppendEnable(int enable)
1881:                     *
1882:                     * PreCondition:    None
1883:                     *
1884:                     * Input:           enable _ boolean to enable/disable the SFM append mode
1885:                     *
1886:                     * Output:          None
1887:                     *
1888:                     * Side Effects:    None
1889:                     *
1890:                     * Overview:        The function enables the SFM append mode. In this mode, the attached DMA channel reads
1891:                     *                  the source data but does not write it to the destination address. The data it's just passed
1892:                     *                  to the checksum generator for CRC/IP checksum calculation.
1893:                     *                  When the block transfer is completed, the checksum result is written to the
1894:                     *                  DMA channel destination address.
1895:                     *
1896:                     * Note:            The SFM module should be properly configured before enabled.
1897:                     *
1898:                     * Example:         DmaSfmAppendModeEnable(TRUE);
1899:                     ********************************************************************/
1900:                    extern __inline__ void __attribute__((always_inline)) DmaSfmAppendEnable(int enable)
1901:                    {
1902:                        if(enable)
1903:                        {
1904:                            DCRCCONSET=_DCRCCON_CRCAPP_MASK;
1905:                        }
1906:                        else
1907:                        {
1908:                            DCRCCONCLR=_DCRCCON_CRCAPP_MASK;
1909:                        }
1910:                    }
1911:                    #define     DmaCrcAppendModeEnable  DmaSfmAppendEnable  // PIC32_3xx backward compatibility
1912:                
1913:                
1914:                    /*********************************************************************
1915:                     * Function:        int DmaSfmGetAppendMode(void)
1916:                     *
1917:                     * PreCondition:    None
1918:                     *
1919:                     * Input:           None
1920:                     *
1921:                     * Output:          TRUE, if the SFM append mode is enabled
1922:                     *                  FALSE otherwise
1923:                     *
1924:                     * Side Effects:    None
1925:                     *
1926:                     * Overview:        The function returns the SFM module enabling status.
1927:                     *
1928:                     * Note:            None
1929:                     *
1930:                     * Example:         int isAppendEnabled=DmaSfmGetAppendMode();
1931:                     ********************************************************************/
1932:                    extern __inline__ int __attribute__((always_inline)) DmaSfmGetAppendMode(void)
1933:                    {
1934:                        return DCRCCONbits.CRCAPP!=0;
1935:                    }
1936:                    #define DmaCrcGetAppendMode DmaSfmGetAppendMode     // PIC32_3xx backward compatibility
1937:                
1938:                
1939:                    /*********************************************************************
1940:                     * Function:        void DmaSfmSetAttach(DmaChannel chn)
1941:                     *
1942:                     * PreCondition:    chn     - valid DMA channel
1943:                     *
1944:                     * Input:           chn - the DMA channel to be attached to the SFM module (the DMA channel transfers will be routed to the SFM module)
1945:                     *
1946:                     * Output:          None
1947:                     *
1948:                     * Side Effects:    None
1949:                     *
1950:                     * Overview:        The function directly attaches a DMA channel to the SFM module.
1951:                     *
1952:                     * Note:            None
1953:                     *
1954:                     * Example:         DmaSfmSetAttach(DMA_CHANNEL3);
1955:                     ********************************************************************/
1956:                    extern __inline__ void __attribute__((always_inline)) DmaSfmSetAttach(DmaChannel chn)
1957:                    {
1958:                        DCRCCONCLR=_DCRCCON_CRCCH_MASK;
1959:                        DCRCCONSET=chn;
1960:                    }
1961:                    #define     DmaCrcSetAttach     DmaSfmSetAttach     // PIC32_3xx backward compatibility
1962:                
1963:                
1964:                    /*********************************************************************
1965:                     * Function:        DmaChannel DmaSfmGetAttach(void)
1966:                     *
1967:                     * PreCondition:    None
1968:                     *
1969:                     * Input:           None
1970:                     *
1971:                     * Output:          the DMA channel that is currently attached to the CRC module
1972:                     *
1973:                     * Side Effects:    None
1974:                     *
1975:                     * Overview:        The function returns the DMA channel number that is currently attached to the SFM module.
1976:                     *
1977:                     * Note:            None
1978:                     *
1979:                     * Example:         DmaChannel chn=DmaSfmGetAttach();
1980:                     ********************************************************************/
1981:                    extern __inline__ DmaChannel __attribute__((always_inline)) DmaSfmGetAttach(void)
1982:                    {
1983:                        return (DmaChannel)DCRCCONbits.CRCCH;
1984:                    }
1985:                    #define     DmaCrcGetAttach     DmaSfmGetAttach     // PIC32_3xx backward compatibility
1986:                
1987:                    /*********************************************************************
1988:                     * Function:        void DmaCrcSetPLen(int pLen)
1989:                     *
1990:                     * PreCondition:    pLen - valid polynomial length within 1-32
1991:                     *
1992:                     * Input:           pLen    - the length of the CRC generator polynomial
1993:                     *
1994:                     * Output:          None
1995:                     *
1996:                     * Side Effects:    None
1997:                     *
1998:                     * Overview:        The length of the CRC generator polynomial is set as being pLen;
1999:                     *
2000:                     * Note:            None
2001:                     *
2002:                     * Example:         DmaCrcSetPLen(32);
2003:                     ********************************************************************/
2004:                    extern __inline__ void __attribute__((always_inline)) DmaCrcSetPLen(int pLen)
2005:                    {
2006:                        DCRCCONCLR=_DCRCCON_PLEN_MASK;
2007:                        DCRCCONSET=(pLen)-1;
2008:                    }
2009:                
2010:                    /*********************************************************************
2011:                     * Function:        int DmaCrcGetPLen(void)
2012:                     *
2013:                     * PreCondition:    None
2014:                     *
2015:                     * Input:           None
2016:                     *
2017:                     * Output:          the length of the CRC generator polynomial
2018:                     *
2019:                     * Side Effects:    None
2020:                     *
2021:                     * Overview:        The function returns the current length of the CRC generator polynomial.
2022:                     *                  It's always a number between 1 and 32.
2023:                     *
2024:                     * Note:            None
2025:                     *
2026:                     * Example:         int polyLen=DmaCrcGetPLen();
2027:                     ********************************************************************/
2028:                    extern __inline__ int __attribute__((always_inline)) DmaCrcGetPLen(void)
2029:                    {
2030:                        return  DCRCCONbits.PLEN+1;
2031:                    }
2032:                
2033:                    /*********************************************************************
2034:                     * Function:        void DmaCrcSetShiftFeedback(unsigned int feedback)
2035:                     *
2036:                     * PreCondition:    None
2037:                     *
2038:                     * Input:           feedback - the layout of the CRC generator
2039:                     *
2040:                     * Output:          None
2041:                     *
2042:                     * Side Effects:    None
2043:                     *
2044:                     * Overview:        The function sets the layout of the shift stages that take place in the CRC generation.
2045:                     *                  Setting a bit to 1 enables the XOR input from the MSb (pLen bit) to the selected stage in the shift register.
2046:                     *                  If bit is cleared, the selected shift stage gets data directly from the previous stage in the shift register.
2047:                     *
2048:                     * Note:            Bit 0 of the generator polynomial is always XOR'ed.
2049:                     *
2050:                     * Example:         DmaCrcSetShiftFeedback(0x04c11db7);
2051:                     ********************************************************************/
2052:                    extern __inline__ void __attribute__((always_inline)) DmaCrcSetShiftFeedback(unsigned int feedback)
2053:                    {
2054:                        DCRCXOR=feedback;
2055:                    }
2056:                
2057:                
2058:                    /*********************************************************************
2059:                     * Function:        unsigned int DmaCrcGetShiftFeedback(void)
2060:                     *
2061:                     * PreCondition:    None
2062:                     *
2063:                     * Input:           None
2064:                     *
2065:                     * Output:          the current layout of the CRC generator
2066:                     *
2067:                     * Side Effects:    None
2068:                     *
2069:                     * Overview:        The function returns the layout of the shift stages that take place in the CRC generation.
2070:                     *                  A bit set to 1 enables the XOR input from the MSb (pLen bit) to the selected stage in the shift register.
2071:                     *                  If a bit is cleared, the selected shift stage gets data directly from the previous stage in the shift register.
2072:                     *
2073:                     * Note:            Bit 0 of the generator polynomial is always XOR'ed.
2074:                     *
2075:                     * Example:         int feedback=DmaCrcGetShiftFeedback();
2076:                     ********************************************************************/
2077:                    extern __inline__ unsigned int __attribute__((always_inline)) DmaCrcGetShiftFeedback(void)
2078:                    {
2079:                        return DCRCXOR;
2080:                    }
2081:                
2082:                
2083:                
2084:                    // Channel test/debug and special functions
2085:                
2086:                    /*********************************************************************
2087:                     * Function:        void DmaChnSetEvFlags(DmaChannel chn, DmaEvFlags eFlags)
2088:                     *
2089:                     * PreCondition:    chn - valid DMA channel
2090:                     *
2091:                     * Input:           chn     - DMA channel number
2092:                     *                  eFlags  - event flags with the following significance:
2093:                     *                              - DMA_EV_ERR: address error event
2094:                     *                              - DMA_EV_ABORT: transfer abort event
2095:                     *                              - DMA_EV_CELL_DONE: cell transfer complete event
2096:                     *                              - DMA_EV_BLOCK_DONE: block transfer complete event
2097:                     *                              - DMA_EV_DST_HALF: destination half event
2098:                     *                              - DMA_EV_DST_FULL: destination full event
2099:                     *                              - DMA_EV_SRC_HALF: source half event
2100:                     *                              - DMA_EV_SRC_FULL: source full event
2101:                     *                              - DMA_EV_ALL_EVNTS: all of the above flags
2102:                     *
2103:                     * Output:          None
2104:                     *
2105:                     * Side Effects:    None
2106:                     *
2107:                     * Overview:        The function sets the event flags for the selected DMA channel.
2108:                     *                  Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
2109:                     *                  set for the selected channel, the other channel event flags won't be touched.
2110:                     *
2111:                     * Note:            This is intended as a channel test function.
2112:                     *
2113:                     * Example:         DmaChnSetEvFlags(DMA_CHANNEL0, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
2114:                     ********************************************************************/
2115:                     void           DmaChnSetEvFlags(DmaChannel chn, DmaEvFlags eFlags);
2116:                
2117:                    /*********************************************************************
2118:                     * Function:        void DmaChnWriteEvFlags(DmaChannel chn, DmaEvFlags eFlags)
2119:                     *
2120:                     * PreCondition:    chn - valid DMA channel
2121:                     *
2122:                     * Input:           chn     - DMA channel number
2123:                     *                  eFlags  - event flags with the following significance:
2124:                     *                              - DMA_EV_ERR: address error event
2125:                     *                              - DMA_EV_ABORT: transfer abort event
2126:                     *                              - DMA_EV_CELL_DONE: cell transfer complete event
2127:                     *                              - DMA_EV_BLOCK_DONE: block transfer complete event
2128:                     *                              - DMA_EV_DST_HALF: destination half event
2129:                     *                              - DMA_EV_DST_FULL: destination full event
2130:                     *                              - DMA_EV_SRC_HALF: source half event
2131:                     *                              - DMA_EV_SRC_FULL: source full event
2132:                     *                              - DMA_EV_ALL_EVNTS: all of the above flags
2133:                     *
2134:                     * Output:          None
2135:                     *
2136:                     * Side Effects:    None
2137:                     *
2138:                     * Overview:        The function writes the event flags for the selected DMA channel.
2139:                     *                  The channel event flags are forced to the eFlags value.
2140:                     *
2141:                     * Note:            This is intended as a channel test function.
2142:                     *
2143:                     * Example:         DmaChnWriteEvFlags(DMA_CHANNEL0, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
2144:                     ********************************************************************/
2145:                     void           DmaChnWriteEvFlags(DmaChannel chn, DmaEvFlags eFlags);
2146:                
2147:                
2148:                    /********************************************************************
2149:                     * Include legacy DMA functions
2150:                     * New projects should not use them!
2151:                     * Note that interrupt functions are no longer provided.
2152:                     * The functions in the int.h should be used instead.
2153:                     ********************************************************************/
2154:                    #ifndef _PLIB_DISABLE_LEGACY
2155:                        #include <peripheral/legacy/dma_legacy.h>
2156:                    #endif
2157:                
2158:                
2159:                #else
2160:                    #undef _DMA_CHANNELS        // no DMA channels
2161:                #endif  // _DMAC0
2162:                
2163:                #endif /*_DMA_1XX_2XX_H_*/
2164:                
2165:                
---  /build/bamboo/xml-data/build-dir/XC32-CYXC32-JOB1/xc32-XC32-release-1_42/src48x/gcc/libgcc/libgcc2.c
9D0010A8  00C04021   ADDU T0, A2, ZERO
9D00150C  00C04021   ADDU T0, A2, ZERO
9D0010AC  00804821   ADDU T1, A0, ZERO
9D001510  00801021   ADDU V0, A0, ZERO
9D0010B0  14E0003B   BNE A3, ZERO, 0x9D0011A0
9D0010B4  00A01821   ADDU V1, A1, ZERO
9D001514  14E0003F   BNE A3, ZERO, 0x9D001614
9D001518  00A04821   ADDU T1, A1, ZERO
9D0010B8  00A6102B   SLTU V0, A1, A2
9D0010BC  10400048   BEQ V0, ZERO, 0x9D0011E0
9D0010C0  70C21020   CLZ V0, A2
9D00151C  00A6182B   SLTU V1, A1, A2
9D001520  10600047   BEQ V1, ZERO, 0x9D001640
9D001524  70C31820   CLZ V1, A2
9D0010C4  50400008   BEQL V0, ZERO, 0x9D0010E8
9D0010C8  00083402   SRL A2, T0, 16
9D001528  50600008   BEQL V1, ZERO, 0x9D00154C
9D00152C  00081C02   SRL V1, T0, 16
9D0010D8  00464004   SLLV T0, A2, V0
9D00153C  00664004   SLLV T0, A2, V1
9D0010CC  00021823   SUBU V1, ZERO, V0
9D0010D0  00452804   SLLV A1, A1, V0
9D0010D4  00641806   SRLV V1, A0, V1
9D0010DC  00651825   OR V1, V1, A1
9D001530  00034823   SUBU T1, ZERO, V1
9D001534  00652804   SLLV A1, A1, V1
9D001538  01244806   SRLV T1, A0, T1
9D001540  01254825   OR T1, T1, A1
9D0010E0  00444804   SLLV T1, A0, V0
9D001544  00641004   SLLV V0, A0, V1
9D0010E4  00083402   SRL A2, T0, 16
9D0010E8  0066001B   DIVU V1, A2
9D0010EC  00C001F4   TEQ A2, ZERO
9D0010F0  00002010   MFHI A0
9D0010F4  00005812   MFLO T3
9D0010F8  310CFFFF   ANDI T4, T0, -1
9D0010FC  00095402   SRL T2, T1, 16
9D001100  716C5802   MUL T3, T3, T4
9D001104  00042400   SLL A0, A0, 16
9D001108  008A5025   OR T2, A0, T2
9D00110C  014B682B   SLTU T5, T2, T3
9D001110  0066001B   DIVU V1, A2
9D001114  00C001F4   TEQ A2, ZERO
9D001118  51A00009   BEQL T5, ZERO, 0x9D001140
9D00111C  014B5023   SUBU T2, T2, T3
9D001120  01485021   ADDU T2, T2, T0
9D001124  0148182B   SLTU V1, T2, T0
9D001128  54600005   BNEL V1, ZERO, 0x9D001140
9D00112C  014B5023   SUBU T2, T2, T3
9D001130  014B202B   SLTU A0, T2, T3
9D001134  01481821   ADDU V1, T2, T0
9D001138  0064500B   MOVN T2, V1, A0
9D00113C  014B5023   SUBU T2, T2, T3
9D001140  3123FFFF   ANDI V1, T1, -1
9D001144  0146001B   DIVU T2, A2
9D001148  00C001F4   TEQ A2, ZERO
9D00114C  00004810   MFHI T1
9D001150  00002012   MFLO A0
9D001154  708C2002   MUL A0, A0, T4
9D001158  00094C00   SLL T1, T1, 16
9D00115C  01234825   OR T1, T1, V1
9D001160  0124182B   SLTU V1, T1, A0
9D001164  0146001B   DIVU T2, A2
9D001168  00C001F4   TEQ A2, ZERO
9D00116C  50600009   BEQL V1, ZERO, 0x9D001194
9D001170  01244823   SUBU T1, T1, A0
9D001174  01284821   ADDU T1, T1, T0
9D001178  0128182B   SLTU V1, T1, T0
9D00117C  54600005   BNEL V1, ZERO, 0x9D001194
9D001180  01244823   SUBU T1, T1, A0
9D001184  0124182B   SLTU V1, T1, A0
9D001188  01284021   ADDU T0, T1, T0
9D00118C  0103480B   MOVN T1, T0, V1
9D001190  01244823   SUBU T1, T1, A0
9D001548  00081C02   SRL V1, T0, 16
9D00154C  0123001B   DIVU T1, V1
9D001550  006001F4   TEQ V1, ZERO
9D001554  00006010   MFHI T4
9D001558  00005812   MFLO T3
9D00155C  310AFFFF   ANDI T2, T0, -1
9D001560  00022402   SRL A0, V0, 16
9D001564  00003012   MFLO A2
9D001568  716A3802   MUL A3, T3, T2
9D00156C  000C6400   SLL T4, T4, 16
9D001570  01842025   OR A0, T4, A0
9D001574  0087602B   SLTU T4, A0, A3
9D001578  0123001B   DIVU T1, V1
9D00157C  006001F4   TEQ V1, ZERO
9D001580  1180000B   BEQ T4, ZERO, 0x9D0015B0
9D001584  00872823   SUBU A1, A0, A3
9D001588  00882021   ADDU A0, A0, T0
9D00158C  0088282B   SLTU A1, A0, T0
9D001590  14A00006   BNE A1, ZERO, 0x9D0015AC
9D001594  2566FFFF   ADDIU A2, T3, -1
9D001598  0087282B   SLTU A1, A0, A3
9D00159C  10A00004   BEQ A1, ZERO, 0x9D0015B0
9D0015A0  00872823   SUBU A1, A0, A3
9D0015A4  2566FFFE   ADDIU A2, T3, -2
9D0015A8  00882021   ADDU A0, A0, T0
9D0015AC  00872823   SUBU A1, A0, A3
9D0015B0  3042FFFF   ANDI V0, V0, -1
9D0015B4  00A3001B   DIVU A1, V1
9D0015B8  006001F4   TEQ V1, ZERO
9D0015BC  00004810   MFHI T1
9D0015C0  00003812   MFLO A3
9D0015C4  00002012   MFLO A0
9D0015C8  70EA5002   MUL T2, A3, T2
9D0015CC  00094C00   SLL T1, T1, 16
9D0015D0  01221025   OR V0, T1, V0
9D0015D4  004A482B   SLTU T1, V0, T2
9D0015D8  00A3001B   DIVU A1, V1
9D0015DC  006001F4   TEQ V1, ZERO
9D0015E0  51200009   BEQL T1, ZERO, 0x9D001608
9D0015E4  00061400   SLL V0, A2, 16
9D0015E8  00481021   ADDU V0, V0, T0
9D0015EC  0048402B   SLTU T0, V0, T0
9D0015F0  15000004   BNE T0, ZERO, 0x9D001604
9D0015F4  24E4FFFF   ADDIU A0, A3, -1
9D0015F8  004A502B   SLTU T2, V0, T2
9D0015FC  24E7FFFE   ADDIU A3, A3, -2
9D001600  00EA200B   MOVN A0, A3, T2
9D001604  00061400   SLL V0, A2, 16
9D001608  00821025   OR V0, A0, V0
9D00160C  03E00008   JR RA
9D001610  00001821   ADDU V1, ZERO, ZERO
9D0011E0  14C00006   BNE A2, ZERO, 0x9D0011FC
9D0011E4  71021020   CLZ V0, T0
9D001640  14C00006   BNE A2, ZERO, 0x9D00165C
9D001644  71031820   CLZ V1, T0
9D0011E8  24020001   ADDIU V0, ZERO, 1
9D0011EC  0046001B   DIVU V0, A2
9D0011F0  00C001F4   TEQ A2, ZERO
9D0011F4  00004012   MFLO T0
9D001648  24030001   ADDIU V1, ZERO, 1
9D00164C  0066001B   DIVU V1, A2
9D001650  00C001F4   TEQ A2, ZERO
9D001654  00004012   MFLO T0
9D0011F8  71021020   CLZ V0, T0
9D001658  71031820   CLZ V1, T0
9D0011FC  5440007D   BNEL V0, ZERO, 0x9D0013F4
9D001200  00484004   SLLV T0, T0, V0
9D00165C  5460007B   BNEL V1, ZERO, 0x9D00184C
9D001660  00684004   SLLV T0, T0, V1
9D001204  00A82823   SUBU A1, A1, T0
9D001208  00081C02   SRL V1, T0, 16
9D00120C  3107FFFF   ANDI A3, T0, -1
9D001664  00A82023   SUBU A0, A1, T0
9D001668  00083C02   SRL A3, T0, 16
9D00166C  310BFFFF   ANDI T3, T0, -1
9D001670  24030001   ADDIU V1, ZERO, 1
9D0013F4  24090020   ADDIU T1, ZERO, 32
9D0013F8  01224823   SUBU T1, T1, V0
9D00184C  24020020   ADDIU V0, ZERO, 32
9D001850  00431023   SUBU V0, V0, V1
9D0013FC  01255006   SRLV T2, A1, T1
9D001854  00454806   SRLV T1, A1, V0
9D001418  00452804   SLLV A1, A1, V0
9D00141C  01244806   SRLV T1, A0, T1
9D001420  01252825   OR A1, T1, A1
9D001870  00652804   SLLV A1, A1, V1
9D001874  00441006   SRLV V0, A0, V0
9D001878  00452825   OR A1, V0, A1
9D001428  00444804   SLLV T1, A0, V0
9D001880  00641004   SLLV V0, A0, V1
9D001400  00081C02   SRL V1, T0, 16
9D001404  0143001B   DIVU T2, V1
9D001408  006001F4   TEQ V1, ZERO
9D00140C  00003010   MFHI A2
9D001410  00005812   MFLO T3
9D001414  3107FFFF   ANDI A3, T0, -1
9D001424  00056402   SRL T4, A1, 16
9D00142C  71675802   MUL T3, T3, A3
9D001430  00063400   SLL A2, A2, 16
9D001434  01863025   OR A2, T4, A2
9D001438  00CB202B   SLTU A0, A2, T3
9D00143C  0143001B   DIVU T2, V1
9D001440  006001F4   TEQ V1, ZERO
9D001444  50800006   BEQL A0, ZERO, 0x9D001460
9D001448  00CB3023   SUBU A2, A2, T3
9D00144C  00C83021   ADDU A2, A2, T0
9D001450  00C8202B   SLTU A0, A2, T0
9D001454  10800024   BEQ A0, ZERO, 0x9D0014E8
9D001458  00CB502B   SLTU T2, A2, T3
9D00145C  00CB3023   SUBU A2, A2, T3
9D001460  30AAFFFF   ANDI T2, A1, -1
9D001464  00C3001B   DIVU A2, V1
9D001468  006001F4   TEQ V1, ZERO
9D00146C  00002010   MFHI A0
9D001470  00002812   MFLO A1
9D001474  70A72802   MUL A1, A1, A3
9D001478  00042400   SLL A0, A0, 16
9D00147C  008A2025   OR A0, A0, T2
9D001480  0085502B   SLTU T2, A0, A1
9D001484  00C3001B   DIVU A2, V1
9D001488  006001F4   TEQ V1, ZERO
9D00148C  5140FF60   BEQL T2, ZERO, 0x9D001210
9D001490  00852823   SUBU A1, A0, A1
9D001494  00882021   ADDU A0, A0, T0
9D001498  0088302B   SLTU A2, A0, T0
9D00149C  54C0FF5C   BNEL A2, ZERO, 0x9D001210
9D0014A0  00852823   SUBU A1, A0, A1
9D0014A4  0085502B   SLTU T2, A0, A1
9D0014A8  00883021   ADDU A2, A0, T0
9D0014AC  00CA200B   MOVN A0, A2, T2
9D0014B0  0B400484   J 0x9D001210
9D0014B4  00852823   SUBU A1, A0, A1
9D0014E8  00C82021   ADDU A0, A2, T0
9D0014EC  0B400517   J 0x9D00145C
9D0014F0  008A300B   MOVN A2, A0, T2
9D001858  00083C02   SRL A3, T0, 16
9D00185C  0127001B   DIVU T1, A3
9D001860  00E001F4   TEQ A3, ZERO
9D001864  00003010   MFHI A2
9D001868  00006012   MFLO T4
9D00186C  310BFFFF   ANDI T3, T0, -1
9D00187C  00056C02   SRL T5, A1, 16
9D001884  00001812   MFLO V1
9D001888  718B5002   MUL T2, T4, T3
9D00188C  00063400   SLL A2, A2, 16
9D001890  01A63025   OR A2, T5, A2
9D001894  00CA202B   SLTU A0, A2, T2
9D001898  0127001B   DIVU T1, A3
9D00189C  00E001F4   TEQ A3, ZERO
9D0018A0  5080000B   BEQL A0, ZERO, 0x9D0018D0
9D0018A4  00CA3023   SUBU A2, A2, T2
9D0018A8  00C83021   ADDU A2, A2, T0
9D0018AC  00C8202B   SLTU A0, A2, T0
9D0018B0  14800006   BNE A0, ZERO, 0x9D0018CC
9D0018B4  2583FFFF   ADDIU V1, T4, -1
9D0018B8  00CA202B   SLTU A0, A2, T2
9D0018BC  50800004   BEQL A0, ZERO, 0x9D0018D0
9D0018C0  00CA3023   SUBU A2, A2, T2
9D0018C4  2583FFFE   ADDIU V1, T4, -2
9D0018C8  00C83021   ADDU A2, A2, T0
9D0018CC  00CA3023   SUBU A2, A2, T2
9D0018D0  30ACFFFF   ANDI T4, A1, -1
9D0018D4  00C7001B   DIVU A2, A3
9D0018D8  00E001F4   TEQ A3, ZERO
9D0018DC  00002010   MFHI A0
9D0018E0  00005012   MFLO T2
9D0018E4  00004812   MFLO T1
9D0018E8  714B2802   MUL A1, T2, T3
9D0018EC  00042400   SLL A0, A0, 16
9D0018F0  008C2025   OR A0, A0, T4
9D0018F4  0085602B   SLTU T4, A0, A1
9D0018F8  00C7001B   DIVU A2, A3
9D0018FC  00E001F4   TEQ A3, ZERO
9D001900  5180000B   BEQL T4, ZERO, 0x9D001930
9D001904  00031C00   SLL V1, V1, 16
9D001908  00882021   ADDU A0, A0, T0
9D00190C  0088302B   SLTU A2, A0, T0
9D001910  14C00006   BNE A2, ZERO, 0x9D00192C
9D001914  2549FFFF   ADDIU T1, T2, -1
9D001918  0085302B   SLTU A2, A0, A1
9D00191C  50C00004   BEQL A2, ZERO, 0x9D001930
9D001920  00031C00   SLL V1, V1, 16
9D001924  2549FFFE   ADDIU T1, T2, -2
9D001928  00882021   ADDU A0, A0, T0
9D00192C  00031C00   SLL V1, V1, 16
9D001930  00852023   SUBU A0, A0, A1
9D001934  0B40059D   J 0x9D001674
9D001938  01231825   OR V1, T1, V1
9D001210  00092402   SRL A0, T1, 16
9D001214  00A3001B   DIVU A1, V1
9D001218  006001F4   TEQ V1, ZERO
9D00121C  00005010   MFHI T2
9D001220  00003012   MFLO A2
9D001224  70C73002   MUL A2, A2, A3
9D001228  000A5400   SLL T2, T2, 16
9D00122C  01442025   OR A0, T2, A0
9D001230  0086502B   SLTU T2, A0, A2
9D001234  00A3001B   DIVU A1, V1
9D001238  006001F4   TEQ V1, ZERO
9D00123C  51400009   BEQL T2, ZERO, 0x9D001264
9D001240  00862023   SUBU A0, A0, A2
9D001244  00882021   ADDU A0, A0, T0
9D001248  0088282B   SLTU A1, A0, T0
9D00124C  54A00005   BNEL A1, ZERO, 0x9D001264
9D001250  00862023   SUBU A0, A0, A2
9D001254  0086502B   SLTU T2, A0, A2
9D001258  00882821   ADDU A1, A0, T0
9D00125C  00AA200B   MOVN A0, A1, T2
9D001260  00862023   SUBU A0, A0, A2
9D001264  3126FFFF   ANDI A2, T1, -1
9D001268  0083001B   DIVU A0, V1
9D00126C  006001F4   TEQ V1, ZERO
9D001270  00004810   MFHI T1
9D001274  00002812   MFLO A1
9D001278  70A72802   MUL A1, A1, A3
9D00127C  00094C00   SLL T1, T1, 16
9D001280  01264825   OR T1, T1, A2
9D001284  0125302B   SLTU A2, T1, A1
9D001288  0083001B   DIVU A0, V1
9D00128C  006001F4   TEQ V1, ZERO
9D001290  50C00009   BEQL A2, ZERO, 0x9D0012B8
9D001294  01254823   SUBU T1, T1, A1
9D001298  01284821   ADDU T1, T1, T0
9D00129C  0128182B   SLTU V1, T1, T0
9D0012A0  54600005   BNEL V1, ZERO, 0x9D0012B8
9D0012A4  01254823   SUBU T1, T1, A1
9D0012A8  0125182B   SLTU V1, T1, A1
9D0012AC  01284021   ADDU T0, T1, T0
9D0012B0  0103480B   MOVN T1, T0, V1
9D0012B4  01254823   SUBU T1, T1, A1
9D001674  00023402   SRL A2, V0, 16
9D001678  0087001B   DIVU A0, A3
9D00167C  00E001F4   TEQ A3, ZERO
9D001680  00006810   MFHI T5
9D001684  00006012   MFLO T4
9D001688  00004812   MFLO T1
9D00168C  718B5002   MUL T2, T4, T3
9D001690  000D6C00   SLL T5, T5, 16
9D001694  01A63025   OR A2, T5, A2
9D001698  00CA682B   SLTU T5, A2, T2
9D00169C  0087001B   DIVU A0, A3
9D0016A0  00E001F4   TEQ A3, ZERO
9D0016A4  11A00009   BEQ T5, ZERO, 0x9D0016CC
9D0016A8  00CA2823   SUBU A1, A2, T2
9D0016AC  00C83021   ADDU A2, A2, T0
9D0016B0  00C8202B   SLTU A0, A2, T0
9D0016B4  14800004   BNE A0, ZERO, 0x9D0016C8
9D0016B8  2589FFFF   ADDIU T1, T4, -1
9D0016BC  00CA202B   SLTU A0, A2, T2
9D0016C0  548000A6   BNEL A0, ZERO, 0x9D00195C
9D0016C4  2589FFFE   ADDIU T1, T4, -2
9D0016C8  00CA2823   SUBU A1, A2, T2
9D0016CC  3042FFFF   ANDI V0, V0, -1
9D0016D0  00A7001B   DIVU A1, A3
9D0016D4  00E001F4   TEQ A3, ZERO
9D0016D8  00005010   MFHI T2
9D0016DC  00003012   MFLO A2
9D0016E0  00002012   MFLO A0
9D0016E4  70CB5802   MUL T3, A2, T3
9D0016E8  000A5400   SLL T2, T2, 16
9D0016EC  01421025   OR V0, T2, V0
9D0016F0  004B502B   SLTU T2, V0, T3
9D0016F4  00A7001B   DIVU A1, A3
9D0016F8  00E001F4   TEQ A3, ZERO
9D0016FC  51400009   BEQL T2, ZERO, 0x9D001724
9D001700  00091400   SLL V0, T1, 16
9D001704  00481021   ADDU V0, V0, T0
9D001708  0048402B   SLTU T0, V0, T0
9D00170C  15000004   BNE T0, ZERO, 0x9D001720
9D001710  24C4FFFF   ADDIU A0, A2, -1
9D001714  004B582B   SLTU T3, V0, T3
9D001718  24C6FFFE   ADDIU A2, A2, -2
9D00171C  00CB200B   MOVN A0, A2, T3
9D001720  00091400   SLL V0, T1, 16
9D001724  03E00008   JR RA
9D001728  00821025   OR V0, A0, V0
9D00195C  0B4005B2   J 0x9D0016C8
9D001194  00491006   SRLV V0, T1, V0
9D0012B8  00491006   SRLV V0, T1, V0
9D001198  03E00008   JR RA
9D00119C  00001821   ADDU V1, ZERO, ZERO
9D0012BC  03E00008   JR RA
9D0012C0  00001821   ADDU V1, ZERO, ZERO
9D0011A0  00A7102B   SLTU V0, A1, A3
9D0011A4  14400047   BNE V0, ZERO, 0x9D0012C4
9D0011A8  70EA5020   CLZ T2, A3
9D001614  00A7102B   SLTU V0, A1, A3
9D001618  14400044   BNE V0, ZERO, 0x9D00172C
9D00161C  70E84020   CLZ T0, A3
9D00172C  00001821   ADDU V1, ZERO, ZERO
9D001730  03E00008   JR RA
9D001734  00001021   ADDU V0, ZERO, ZERO
9D0012C4  00801021   ADDU V0, A0, ZERO
9D0012C8  03E00008   JR RA
9D0012CC  00A01821   ADDU V1, A1, ZERO
9D0011AC  15400048   BNE T2, ZERO, 0x9D0012D0
9D0011B0  240B0020   ADDIU T3, ZERO, 32
9D001620  55000045   BNEL T0, ZERO, 0x9D001738
9D001624  24020020   ADDIU V0, ZERO, 32
9D0011B4  00E5102B   SLTU V0, A3, A1
9D0011B8  14400005   BNE V0, ZERO, 0x9D0011D0
9D0011BC  00861023   SUBU V0, A0, A2
9D0011C0  0086402B   SLTU T0, A0, A2
9D0011C4  15000089   BNE T0, ZERO, 0x9D0013EC
9D0011C8  00801021   ADDU V0, A0, ZERO
9D001628  00E5282B   SLTU A1, A3, A1
9D00162C  14A000C8   BNE A1, ZERO, 0x9D001950
9D001630  0086302B   SLTU A2, A0, A2
9D001634  38C20001   XORI V0, A2, 1
9D001638  03E00008   JR RA
9D00163C  00001821   ADDU V1, ZERO, ZERO
9D001950  00001821   ADDU V1, ZERO, ZERO
9D0011CC  00861023   SUBU V0, A0, A2
9D0011D0  00A72823   SUBU A1, A1, A3
9D0011D4  0082202B   SLTU A0, A0, V0
9D0011D8  03E00008   JR RA
9D0011DC  00A41823   SUBU V1, A1, A0
9D0012D0  016A5823   SUBU T3, T3, T2
9D001738  00481023   SUBU V0, V0, T0
9D0012D4  01473804   SLLV A3, A3, T2
9D0012D8  01661006   SRLV V0, A2, T3
9D0012DC  00473825   OR A3, V0, A3
9D00173C  01073804   SLLV A3, A3, T0
9D001740  00461806   SRLV V1, A2, V0
9D001744  00673825   OR A3, V1, A3
9D00130C  01463004   SLLV A2, A2, T2
9D0012E0  01656806   SRLV T5, A1, T3
9D001748  00455006   SRLV T2, A1, V0
9D0012FC  01452804   SLLV A1, A1, T2
9D001300  01641006   SRLV V0, A0, T3
9D001304  00451025   OR V0, V0, A1
9D001764  01052804   SLLV A1, A1, T0
9D001768  00441006   SRLV V0, A0, V0
9D00176C  00452825   OR A1, V0, A1
9D0012E4  00074C02   SRL T1, A3, 16
9D0012E8  01A9001B   DIVU T5, T1
9D0012EC  012001F4   TEQ T1, ZERO
9D0012F0  00006010   MFHI T4
9D0012F4  00001812   MFLO V1
9D0012F8  30EEFFFF   ANDI T6, A3, -1
9D001308  00022C02   SRL A1, V0, 16
9D001310  00004012   MFLO T0
9D001314  706E7802   MUL T7, V1, T6
9D001318  000C6400   SLL T4, T4, 16
9D00131C  01856025   OR T4, T4, A1
9D001320  018F282B   SLTU A1, T4, T7
9D001324  01A9001B   DIVU T5, T1
9D001328  012001F4   TEQ T1, ZERO
9D00132C  10A0000A   BEQ A1, ZERO, 0x9D001358
9D001330  01442004   SLLV A0, A0, T2
9D001334  01876021   ADDU T4, T4, A3
9D001338  0187282B   SLTU A1, T4, A3
9D00133C  14A00006   BNE A1, ZERO, 0x9D001358
9D001340  2468FFFF   ADDIU T0, V1, -1
9D001344  018F282B   SLTU A1, T4, T7
9D001348  50A00004   BEQL A1, ZERO, 0x9D00135C
9D00134C  018F6023   SUBU T4, T4, T7
9D001350  2468FFFE   ADDIU T0, V1, -2
9D001354  01876021   ADDU T4, T4, A3
9D001358  018F6023   SUBU T4, T4, T7
9D00135C  3042FFFF   ANDI V0, V0, -1
9D001360  0189001B   DIVU T4, T1
9D001364  012001F4   TEQ T1, ZERO
9D001368  00002810   MFHI A1
9D00136C  00001812   MFLO V1
9D001370  00006812   MFLO T5
9D001374  706E7002   MUL T6, V1, T6
9D001378  00052C00   SLL A1, A1, 16
9D00137C  00A21025   OR V0, A1, V0
9D001380  004E282B   SLTU A1, V0, T6
9D001384  0189001B   DIVU T4, T1
9D001388  012001F4   TEQ T1, ZERO
9D00138C  50A00006   BEQL A1, ZERO, 0x9D0013A8
9D001390  00084400   SLL T0, T0, 16
9D001394  00471021   ADDU V0, V0, A3
9D001398  0047282B   SLTU A1, V0, A3
9D00139C  10A0004C   BEQ A1, ZERO, 0x9D0014D0
9D0013A0  246DFFFF   ADDIU T5, V1, -1
9D0013A4  00084400   SLL T0, T0, 16
9D0013A8  01A84025   OR T0, T5, T0
9D0013AC  004E1023   SUBU V0, V0, T6
9D0014D0  004E282B   SLTU A1, V0, T6
9D0014D4  50A0FFB4   BEQL A1, ZERO, 0x9D0013A8
9D0014D8  00084400   SLL T0, T0, 16
9D0014DC  246DFFFE   ADDIU T5, V1, -2
9D0014E0  0B4004E9   J 0x9D0013A4
9D0014E4  00471021   ADDU V0, V0, A3
9D00174C  00071C02   SRL V1, A3, 16
9D001750  0143001B   DIVU T2, V1
9D001754  006001F4   TEQ V1, ZERO
9D001758  00004810   MFHI T1
9D00175C  00006812   MFLO T5
9D001760  30EBFFFF   ANDI T3, A3, -1
9D001770  00057402   SRL T6, A1, 16
9D001774  00001012   MFLO V0
9D001778  71AB6002   MUL T4, T5, T3
9D00177C  00094C00   SLL T1, T1, 16
9D001780  012E4825   OR T1, T1, T6
9D001784  012C702B   SLTU T6, T1, T4
9D001788  0143001B   DIVU T2, V1
9D00178C  006001F4   TEQ V1, ZERO
9D001790  11C0000A   BEQ T6, ZERO, 0x9D0017BC
9D001794  01063004   SLLV A2, A2, T0
9D001798  01274821   ADDU T1, T1, A3
9D00179C  0127502B   SLTU T2, T1, A3
9D0017A0  15400006   BNE T2, ZERO, 0x9D0017BC
9D0017A4  25A2FFFF   ADDIU V0, T5, -1
9D0017A8  012C502B   SLTU T2, T1, T4
9D0017AC  51400004   BEQL T2, ZERO, 0x9D0017C0
9D0017B0  012C4823   SUBU T1, T1, T4
9D0017B4  25A2FFFE   ADDIU V0, T5, -2
9D0017B8  01274821   ADDU T1, T1, A3
9D0017BC  012C4823   SUBU T1, T1, T4
9D0017C0  30A5FFFF   ANDI A1, A1, -1
9D0017C4  0123001B   DIVU T1, V1
9D0017C8  006001F4   TEQ V1, ZERO
9D0017CC  00006810   MFHI T5
9D0017D0  00006012   MFLO T4
9D0017D4  00005012   MFLO T2
9D0017D8  718B5802   MUL T3, T4, T3
9D0017DC  000D6C00   SLL T5, T5, 16
9D0017E0  01A52825   OR A1, T5, A1
9D0017E4  00AB682B   SLTU T5, A1, T3
9D0017E8  0123001B   DIVU T1, V1
9D0017EC  006001F4   TEQ V1, ZERO
9D0017F0  51A0000B   BEQL T5, ZERO, 0x9D001820
9D0017F4  00021400   SLL V0, V0, 16
9D0017F8  00A72821   ADDU A1, A1, A3
9D0017FC  00A7182B   SLTU V1, A1, A3
9D001800  14600006   BNE V1, ZERO, 0x9D00181C
9D001804  258AFFFF   ADDIU T2, T4, -1
9D001808  00AB182B   SLTU V1, A1, T3
9D00180C  50600004   BEQL V1, ZERO, 0x9D001820
9D001810  00021400   SLL V0, V0, 16
9D001814  258AFFFE   ADDIU T2, T4, -2
9D001818  00A72821   ADDU A1, A1, A3
9D00181C  00021400   SLL V0, V0, 16
9D001820  01421025   OR V0, T2, V0
9D001824  00AB2823   SUBU A1, A1, T3
9D0013B0  01060019   MULTU 0, T0, A2
9D0013B4  00004810   MFHI T1
9D0013CC  00003012   MFLO A2
9D001828  00460019   MULTU 0, V0, A2
9D00182C  00003810   MFHI A3
9D0013B8  0049182B   SLTU V1, V0, T1
9D0013BC  1460003E   BNE V1, ZERO, 0x9D0014B8
9D0013C0  00004012   MFLO T0
9D0013C4  1049004B   BEQ V0, T1, 0x9D0014F4
9D0013C8  00491823   SUBU V1, V0, T1
9D0014F4  0088182B   SLTU V1, A0, T0
9D001830  00A7182B   SLTU V1, A1, A3
9D001834  14600044   BNE V1, ZERO, 0x9D001948
9D001838  00003012   MFLO A2
9D00183C  10A7003F   BEQ A1, A3, 0x9D00193C
9D001840  01042004   SLLV A0, A0, T0
9D00193C  0086302B   SLTU A2, A0, A2
9D001940  10C0FFC0   BEQ A2, ZERO, 0x9D001844
9D001944  00000000   NOP
9D001844  03E00008   JR RA
9D001848  00001821   ADDU V1, ZERO, ZERO
9D001948  0B400611   J 0x9D001844
9D00194C  2442FFFF   ADDIU V0, V0, -1
9D0014B8  01063023   SUBU A2, T0, A2
9D0014BC  01271823   SUBU V1, T1, A3
9D0014C0  0106402B   SLTU T0, T0, A2
9D0014C4  00681823   SUBU V1, V1, T0
9D0014C8  0B4004F4   J 0x9D0013D0
9D0014CC  00431823   SUBU V1, V0, V1
9D0013D0  00863023   SUBU A2, A0, A2
9D0013D4  0086202B   SLTU A0, A0, A2
9D0013D8  00641823   SUBU V1, V1, A0
9D0013DC  01631004   SLLV V0, V1, T3
9D0013E0  01463006   SRLV A2, A2, T2
9D0013E4  00461025   OR V0, V0, A2
9D0013E8  01431806   SRLV V1, V1, T2
9D0013EC  03E00008   JR RA
9D0013F0  00000000   NOP
9D0013F4  24090020   ADDIU T1, ZERO, 32
9D0013F8  01224823   SUBU T1, T1, V0
9D0013FC  01255006   SRLV T2, A1, T1
9D001400  00081C02   SRL V1, T0, 16
9D001404  0143001B   DIVU T2, V1
9D001408  006001F4   TEQ V1, ZERO
9D00140C  00003010   MFHI A2
9D001410  00005812   MFLO T3
9D001414  3107FFFF   ANDI A3, T0, -1
9D001418  00452804   SLLV A1, A1, V0
9D00141C  01244806   SRLV T1, A0, T1
9D001420  01252825   OR A1, T1, A1
9D001424  00056402   SRL T4, A1, 16
9D001428  00444804   SLLV T1, A0, V0
9D00142C  71675802   MUL T3, T3, A3
9D001430  00063400   SLL A2, A2, 16
9D001434  01863025   OR A2, T4, A2
9D001438  00CB202B   SLTU A0, A2, T3
9D00143C  0143001B   DIVU T2, V1
9D001440  006001F4   TEQ V1, ZERO
9D001444  50800006   BEQL A0, ZERO, 0x9D001460
9D001448  00CB3023   SUBU A2, A2, T3
9D00144C  00C83021   ADDU A2, A2, T0
9D001450  00C8202B   SLTU A0, A2, T0
9D001454  10800024   BEQ A0, ZERO, 0x9D0014E8
9D001458  00CB502B   SLTU T2, A2, T3
9D00145C  00CB3023   SUBU A2, A2, T3
9D001460  30AAFFFF   ANDI T2, A1, -1
9D001464  00C3001B   DIVU A2, V1
9D001468  006001F4   TEQ V1, ZERO
9D00146C  00002010   MFHI A0
9D001470  00002812   MFLO A1
9D001474  70A72802   MUL A1, A1, A3
9D001478  00042400   SLL A0, A0, 16
9D00147C  008A2025   OR A0, A0, T2
9D001480  0085502B   SLTU T2, A0, A1
9D001484  00C3001B   DIVU A2, V1
9D001488  006001F4   TEQ V1, ZERO
9D00148C  5140FF60   BEQL T2, ZERO, 0x9D001210
9D001490  00852823   SUBU A1, A0, A1
9D001494  00882021   ADDU A0, A0, T0
9D001498  0088302B   SLTU A2, A0, T0
9D00149C  54C0FF5C   BNEL A2, ZERO, 0x9D001210
9D0014A0  00852823   SUBU A1, A0, A1
9D0014A4  0085502B   SLTU T2, A0, A1
9D0014A8  00883021   ADDU A2, A0, T0
9D0014AC  00CA200B   MOVN A0, A2, T2
9D0014B0  0B400484   J 0x9D001210
9D0014B4  00852823   SUBU A1, A0, A1
9D0014B8  01063023   SUBU A2, T0, A2
9D0014BC  01271823   SUBU V1, T1, A3
9D0014C0  0106402B   SLTU T0, T0, A2
9D0014C4  00681823   SUBU V1, V1, T0
9D0014C8  0B4004F4   J 0x9D0013D0
9D0014CC  00431823   SUBU V1, V0, V1
9D0014D0  004E282B   SLTU A1, V0, T6
9D0014D4  50A0FFB4   BEQL A1, ZERO, 0x9D0013A8
9D0014D8  00084400   SLL T0, T0, 16
9D0014DC  246DFFFE   ADDIU T5, V1, -2
9D0014E0  0B4004E9   J 0x9D0013A4
9D0014E4  00471021   ADDU V0, V0, A3
9D0014E8  00C82021   ADDU A0, A2, T0
9D0014EC  0B400517   J 0x9D00145C
9D0014F0  008A300B   MOVN A2, A0, T2
9D0014F4  0088182B   SLTU V1, A0, T0
9D0014F8  5460FFF0   BNEL V1, ZERO, 0x9D0014BC
9D0014FC  01063023   SUBU A2, T0, A2
9D001500  00003012   MFLO A2
9D001504  0B4004F4   J 0x9D0013D0
9D001508  00001821   ADDU V1, ZERO, ZERO
9D001954  03E00008   JR RA
9D001958  24020001   ADDIU V0, ZERO, 1
9D00195C  0B4005B2   J 0x9D0016C8
9D001960  00C83021   ADDU A2, A2, T0
